#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 1998-10-29 02:16 EST by <pbh@heinrich.top.cis.syr.edu>.
# Source directory was `/home/cisfac/pbh/temporary'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   6684 -rw------- readthis.tex
#  45071 -rw------- report.tex
#  10425 -rw------- user.tex
#  10504 -rw------- notes.tex
#   7919 -rw------- common.p
#  16455 -rw------- scan.p
#  92663 -rw------- parse.p
#   9910 -rw------- assemble.p
#   6459 -rw------- compile.p
#  41292 -rw------- interpret.p
#    107 -rw------- sun3.user
#    103 -rw------- sun4.user
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
touch -am 1231235999 $$.touch >/dev/null 2>&1
if test ! -f 1231235999 && test -f $$.touch; then
  shar_touch=touch
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 1231235999 $$.touch
#
if mkdir _sh04862; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= readthis.tex ==============
if test -f 'readthis.tex' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'readthis.tex' '(file already exists)'
else
  $echo 'x -' extracting 'readthis.tex' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'readthis.tex' &&
%  ANONYMOUS FTP OF THE SUPERPASCAL SOFTWARE
%              PER BRINCH HANSEN
%  School of Computer and Information Science
% Syracuse University, Syracuse, NY 13244, USA
%               29 October 1993
%     Copyright(c) 1993 Per Brinch Hansen
X
% LATEX PREAMBLE
\documentstyle[twoside,11pt]{article}
\pagestyle{myheadings}
\setlength{\topmargin}{7mm}
\setlength{\textheight}{200mm}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{14mm}
\setlength{\evensidemargin}{12mm}
\newcommand{\acknowledgements}
X  {\section*{Acknowledgements}
X   \addcontentsline{toc}{section}
X     {Acknowledgements}
X  }
\newcommand{\blank}
X  {\mbox{\hspace{1.8em}}}
\newcommand{\blankline}
X  {\medskip}
\newcommand{\Copyright}
X  {Copyright {\copyright}}
\newcommand{\entry}
X  {\bibitem{}}
\newcommand{\example}
X  {{\it Example:}}
\newcommand{\examples}
X  {{\it Examples:}}
\newcommand{\mytitle}[3]
% [title,month,year]
X  {\markboth{PER BRINCH HANSEN}{#1}
X   \thispagestyle{empty}
X   \begin{center}
X     {\Large\bf #1}\\
X     % TITLE    
X     \blankline
X       PER BRINCH HANSEN\\
X     \blankline
X     {\it
X       School of Computer and Information Science  \\
X       Syracuse University, Syracuse, NY 13244, USA\\
X     }
X     \blankline
X     #2 #3\\
X     %  Month Year
X   \end{center}
X  }
\newcommand{\Superpascal}
X  {\it SuperPascal}
\newenvironment{grammar}
X  {\begin{small}}
X  {\end{small}}
\newenvironment{myabstract}
X  {\begin{rm}
X     \noindent{\bf Abstract:}}
X  {\end{rm}}
\newenvironment{mybibliography}[1]
% [widestlabel]
X  {\begin{small}
X    \begin{thebibliography}{#1}
X      \addcontentsline{toc}
X        {section}{References}}
X  {  \end{thebibliography}
X   \end{small}}
\newenvironment{mykeywords}
X  {\begin{small}
X     \noindent{\bf Key Words:}}
X  {\end{small}}
\newenvironment{mytabular}[1]
% [columns]
X  {\begin{small}
X     \begin{center}
X       \begin{tabular}{#1}}
X  {    \end{tabular}
X     \end{center}
X   \end{small}}
\newenvironment{program}[1]
% [width]
X  {\begin{center}
X     \begin{minipage}{#1}}
X  {  \end{minipage}
X   \end{center}}
% Program Indentation
\newcommand{\PA}
X  {\noindent}
\newcommand{\PB}
X  {\mbox{\hspace{1em}}}
\newcommand{\PC}
X  {\mbox{\hspace{2em}}}
\newcommand{\PD}
X  {\mbox{\hspace{3em}}}
\newcommand{\PE}
X  {\mbox{\hspace{4em}}}
X
% DOCUMENT TEXT
\begin{document}
X
\mytitle{ANONYMOUS FTP OF THE SUPERPASCAL SOFTWARE}
X  {November}{1993}
X
\noindent
These instructions describe the {\Superpascal} software,
define the terms and conditions for its use, and explain how
you obtain the software by anonymous FTP.
X
\begin{center}
X  {\bf DEFINITIONS}
\end{center}
X
\noindent
The {\it SuperPascal} software (hereafter {\it Software}) is
educational software written by Per Brinch Hansen (hereafter
{\it PBH}). The {\it Software} consists of the {\it Manuals},
{\it Programs}, and {\it Scripts} for the programming
language {\Superpascal} invented by {\it PBH}. The {\it
Software} is stored as text in 11 files (hereafter {\it
Files}).
X
The {\it Manuals}, written by {\it PBH}, are stored as {\LaTeX}
text in 3 {\it Files}:
X
\begin{itemize}
X  \item
X  {\it report.tex:} ``The programming language SuperPascal.''
X  \item
X  {\it user.tex:} ``The SuperPascal user manual.''
X  \item
X  {\it notes.tex:} ``The SuperPascal software notes.''
\end{itemize}
X
The {\it Programs}, written by {\it PBH}, are a {\Superpascal}
compiler and interpreter (hereafter {\it Compiler} and {\it
Interpreter}). The {\it Programs} are written in Pascal for
Sun3 and Sun4 workstations running Unix. The {\it Programs}
are stored as Pascal text in 6 {\it Files}:
X
\begin{itemize}
X  \item
X  {\it common.p:} The common declarations used by the
X  {\it Compiler} and {\it Interpreter}.
X  \item
X  {\it scan.p:} The {\it Compiler} procedure that performs
X  lexical analysis.
X  \item
X  {\it parse.p:} The {\it Compiler} procedure that performs
X  syntax, scope, and type analysis.
X  \item
X  {\it assemble.p:} The {\it Compiler} procedure that
X  assembles interpreted code.
X  \item
X  {\it compile.p:} The {\it Compiler} program.
X  \item
X  {\it interpret.p:} The {\it Interpreter} program.
\end{itemize}
X
The {\it Scripts} are Unix shell scripts stored as text in 2
{\it Files}:
X
\begin{itemize}
X  \item
X  {\it sun3.user:} A shell script for compilation of the
X  {\it Programs} on a Sun3 workstation under Unix.
X  \item
X  {\it sun4.user:} A shell script for compilation of the
X  {\it Programs} on a Sun4 workstation under Unix.
\end{itemize}
X
\begin{center}
X  {\bf TERMS AND CONDITIONS}
\end{center}
X
\begin{it}
\noindent
THE MANUALS ARE COPYRIGHTED BY PBH. THE PROGRAMS ARE IN THE
PUBLIC DOMAIN. YOU CAN OBTAIN THE SOFTWARE BY ANONYMOUS FTP.
THE SOFTWARE IS NOT GUARANTEED FOR A PARTICULAR PURPOSE. PBH
SUPPLIES THE SOFTWARE ``AS IS'' WITHOUT ANY WARRANTIES OR
REPRESENTATIONS AND DOES NOT ACCEPT ANY LIABILITIES WITH
RESPECT TO THE SOFTWARE.
YOU (THE USER) ARE RESPONSIBLE FOR SELECTING THE SOFTWARE, AND
FOR THE USE AND RESULTS OBTAINED FROM THE SOFTWARE. YOUR USE
OF THE SOFTWARE INDICATES YOUR ACCEPTANCE OF THESE TERMS AND
CONDITIONS.
\end{it}
X
\begin{center}
X  {\bf FILE TRANSFER PROCEDURE}
\end{center}
X
\noindent
To obtain the software, use anonymous FTP from the directory
{\it pbh@top.cis.syr.edu}. If your local machine runs Unix,
follow these steps to copy the files:
X
\blankline
X
Create an empty directory on your local machine by typing
X
\begin{center}
X  mkdir clone
\end{center}
X
Enter the local directory by typing
X
\begin{center}
X  cd clone
\end{center}
X
Select the remote machine by typing
X
\begin{center}
X  ftp top.cis.syr.edu
\end{center}
X
When prompted for your name, type
X
\begin{center}
X  anonymous
\end{center}
X
When prompted for your password, type your
X
\begin{center}
X  $<$e-mail address$>$
\end{center}
X
Enter the remote ftp directory by typing
X
\begin{center}
X  cd pbh
\end{center}
X
Copy a shell archive that contains the {\it Files} by
typing
X
\begin{center}
X  get software.shar
\end{center}
X
Leave the remote machine by typing
X
\begin{center}
X  bye
\end{center}
X
Split the archive into {\it Files} by typing
X
\begin{center}
X  sh software.shar
\end{center}
X
Your local directory should now contain the Files.
X
\begin{center}
X  {\bf HOW TO GET STARTED}
\end{center}
X
\noindent
Transform the {\LaTeX} files into PostScript files and
print the {\it Manuals}. Read ``The SuperPascal software
notes" which explain how you compile the {\it Programs}
on Sun3 and Sun4 workstations. Compile the {\it Programs}
into two executable files:
X
\begin{program}{14.1em}
X  {\PA}sc{\blank}An executable {\it Compiler}.   \\
X  {\PA}sr{\blank}An executable {\it Interpreter}.\\
\end{program}
X
Then read "The programming language SuperPascal" and "The
SuperPascal user manual."
X
\end{document}
SHAR_EOF
  $shar_touch -am 1029021698 'readthis.tex' &&
  chmod 0600 'readthis.tex' ||
  $echo 'restore of' 'readthis.tex' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'readthis.tex:' 'MD5 check failed'
cc18e09a976af51e5451487517ddfb0e  readthis.tex
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'readthis.tex'`"
    test 6684 -eq "$shar_count" ||
    $echo 'readthis.tex:' 'original size' '6684,' 'current size' "$shar_count!"
  fi
fi
# ============= report.tex ==============
if test -f 'report.tex' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'report.tex' '(file already exists)'
else
  $echo 'x -' extracting 'report.tex' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'report.tex' &&
%     THE PROGRAMMING LANGUAGE SUPERPASCAL
%              PER BRINCH HANSEN
%  School of Computer and Information Science
% Syracuse University, Syracuse, NY 13244, USA
%              10 November 1993
%     Copyright(c) 1993 Per Brinch Hansen
X
% LATEX PREAMBLE
% For 11pt, 1em = 3.83mm
\documentstyle[twoside,11pt]{article}
\pagestyle{myheadings}
\setlength{\topmargin}{7mm}
\setlength{\textheight}{200mm}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{14mm}
\setlength{\evensidemargin}{12mm}
\newcommand{\acknowledgements}
X  {\section*{Acknowledgements}
X   \addcontentsline{toc}{section}
X     {Acknowledgements}
X  }
\newcommand{\blank}
X  {\mbox{\hspace{1.8em}}}
\newcommand{\blankline}
X  {\medskip}
\newcommand{\Copyright}
X  {Copyright {\copyright}}
\newcommand{\entry}
X  {\bibitem{}}
\newcommand{\example}
X  {{\it Example:}}
\newcommand{\examples}
X  {{\it Examples:}}
\newcommand{\mytitle}[3]
% [title,month,year]
X  {\markboth{Per Brinch Hansen}{#1}
X   \thispagestyle{empty}
X   \begin{center}
X     {\Large\bf #1}\\
X     % TITLE    
X     \blankline
X       PER BRINCH HANSEN
X     \footnote{
X       \Copyright #3 % Year
X       Per Brinch Hansen. All rights reserved.}\\
X     \blankline
X     {\it
X       School of Computer and Information Science  \\
X       Syracuse University, Syracuse, NY 13244, USA\\
X     }
X     \blankline
X     #2 #3\\
X     %  Month Year
X   \end{center}
X  }
\newcommand{\Superpascal}
X  {\it SuperPascal}
\newenvironment{grammar}
X  {\begin{small}}
X  {\end{small}}
\newenvironment{myabstract}
X  {\begin{rm}
X     \noindent{\bf Abstract:}}
X  {\end{rm}}
\newenvironment{mybibliography}[1]
% [widestlabel]
X  {\begin{small}
X    \begin{thebibliography}{#1}
X      \addcontentsline{toc}
X        {section}{References}}
X  {  \end{thebibliography}
X   \end{small}}
\newenvironment{mykeywords}
X  {\begin{small}
X     \noindent{\bf Key Words:}}
X  {\end{small}}
\newenvironment{mytabular}[1]
% [columns]
X  {\begin{small}
X     \begin{center}
X       \begin{tabular}{#1}}
X  {    \end{tabular}
X     \end{center}
X   \end{small}}
\newenvironment{program}[1]
% [width]
X  {\begin{center}
X     \begin{minipage}{#1}}
X  {  \end{minipage}
X   \end{center}}
% Program Tokens
\newcommand{\token}[1]
X  {{\bf#1}}
\newcommand{\And}
X  {\token{and}}
\newcommand{\Array}
X  {\token{array}}
\newcommand{\Assume}
X  {\token{assume}}
\newcommand{\Begin}
X  {\token{begin}}
\newcommand{\Case}
X  {\token{case}}
\newcommand{\Const}
X  {\token{const}}
\newcommand{\Div}
X  {\token{div}}
\newcommand{\Do}
X  {\token{do}}
\newcommand{\Downto}
X  {\token{downto}}
\newcommand{\Else}
X  {\token{else}}
\newcommand{\End}
X  {\token{end}}
\newcommand{\For}
X  {\token{for}}
\newcommand{\Forall}
X  {\token{forall}}
\newcommand{\Function}
X  {\token{function}}
\newcommand{\If}
X  {\token{if}}
\newcommand{\Mod}
X  {\token{mod}}
\newcommand{\Not}
X  {\token{not}}
\newcommand{\Of}
X  {\token{of}}
\newcommand{\Or}
X  {\token{or}}
\newcommand{\Parallel}
X  {\token{parallel}}
\newcommand{\Procedure}
X  {\token{procedure}}
\newcommand{\Program}
X  {\token{program}}
\newcommand{\Record}
X  {\token{record}}
\newcommand{\Repeat}
X  {\token{repeat}}
\newcommand{\Sic}
X  {\token{sic}}
\newcommand{\Then}
X  {\token{then}}
\newcommand{\To}
X  {\token{to}}
\newcommand{\Type}
X  {\token{type}}
\newcommand{\Until}
X  {\token{until}}
\newcommand{\Var}
X  {\token{var}}
\newcommand{\While}
X  {\token{while}}
% Program Indentation
\newcommand{\PA}
X  {\noindent}
\newcommand{\PB}
X  {\mbox{\hspace{1em}}}
\newcommand{\PC}
X  {\mbox{\hspace{2em}}}
\newcommand{\PD}
X  {\mbox{\hspace{3em}}}
\newcommand{\PE}
X  {\mbox{\hspace{4em}}}
% Grammar Indentation
\newcommand{\GA}
X  {\noindent}
\newcommand{\GB}
X  {\mbox{\hspace{1.6em}}}
\newcommand{\GC}
X  {\mbox{\hspace{3.2em}}}
\newcommand{\GD}
X  {\mbox{\hspace{4.8em}}}
\hyphenation{
X  syn-chron-ous
}
% DOCUMENT TEXT
\begin{document}
X
\mytitle
X  {The Programming Language SuperPascal}
X  {November}{1993}
X
\begin{myabstract}
X  This paper defines {\Superpascal}---a secure programming
X  language for publication of parallel scientific
X  algorithms. {\Superpascal} extends a subset of IEEE Standard
X  Pascal with deterministic statements for parallel
X  processes and synchronous message communication. A parallel
X  statement denotes parallel execution of a fixed number of
X  statements. A {\it forall} statement denotes parallel execution
X  of the same statement by a dynamic number of processes.
X  Recursive procedures may be combined with parallel and {\it
X  forall} statements to define recursive parallel processes.
X  Parallel processes communicate by sending typed messages
X  through channels created dynamically. {\Superpascal} omits
X  ambiguous and insecure features of Pascal. Restrictions on
X  the use of variables enable a single-pass compiler to check
X  that parallel processes are disjoint, even if the processes
X  use procedures with global variables.
\end{myabstract}
X
\blankline
X
\begin{mykeywords}
X  Programming languages, Parallel programming, Recursive
X  parallelism, Synchronous communication, SuperPascal.
\end{mykeywords}
X
%\tableofcontents
X
X
\section{Introduction}
X
This paper defines {\Superpascal}---a secure programming
language for publication of parallel scientific algorithms.
{\Superpascal} extends a subset of IEEE Standard Pascal with
deterministic statements for parallel processes and
synchronous message communication. A parallel statement
denotes parallel execution of a fixed number of statements.
A {\it forall} statement denotes parallel execution of the
same statement by a dynamic number of processes. Recursive
procedures may be combined with parallel and {\it forall}
statements to define recursive parallel processes. Parallel
processes communicate by sending typed message through
channels created dynamically. {\Superpascal} omits ambiguous
and insecure features of Pascal. Restrictions on the use of
variables enable a single-pass compiler to check that
parallel processes are disjoint, even if the processes use
procedures with global variables.
X
This paper defines the parallel features of {\Superpascal}
using the terminology and syntax notation of the Standard
Pascal report [IEEE 1983]. Brinch Hansen [1993a]
illustrates {\Superpascal} by examples. The syntactic
checking of parallel statements is discussed further in
[Brinch Hansen 1993b].
X
A {\it portable implementation} of {\Superpascal} has been
developed on a Sun workstation under Unix. It consists of
a compiler and an interpreter written in Pascal. To obtain
the {\Superpascal} software, use anonymous FTP from the
directory {\it pbh} at {\it top.cis.syr.edu}.
X
X
\section{Processes and Variables}
X
\begin{grammar}
X  {\GA}command =                           \\
X    {\GB}variable-access $|$ expression $|$
X         statement $|$ statement-sequence .
\end{grammar}
X
The evaluation or execution of a {\it command} is called a
{\it process}. A structured process is a sequential or
parallel composition of processes. The components of a
parallel composition are called {\it parallel processes}.
They proceed independently at unpredictable speeds until all
of them have terminated.
X
In a program text an {\it entire variable} is a syntactic
entity that has an identifier, a type, and a scope.
X
During program execution a {\it block} is activated when a
process evaluates a function designator or executes a
procedure statement or program. Every activation of a block
$B$ creates a new instance of every variable that is local
to $B$. When an activation terminates, the corresponding
variable instances cease to exist.
X
During recursive and parallel activations of a block,
multiple instances of the local variables exist. Each
variable instance is a dynamic entity that has a location, a
current value, and a finite lifetime in memory.
X
The distinction between a {\it variable} as a syntactic
entity in the program text and a class of dynamic entities
in memory is usually clear from the context. Where it is
necessary, this paper distinguishes between {\it syntactic
variables} and {\it variable instances}.
X
Parallel processes are said to be {\it disjoint} if they
satisfy the following condition: Any variable instance that
is assigned a value by one of the processes is not
accessed by any of the other processes. In other words, any
variable instance that is accessed by more than one process
is not assigned a value by any of the processes.
X
X
\section{Type Definitions}
X
Every type has an identifier. Two types are the same if they
have the same identifier and the same scope.
X
\blankline
X
\examples
X
\blankline
X
The following types are used in the examples of this paper:
X
\begin{program}{20.4em}
X  {\PA}{\Type}                                            \\
X    {\PB}vector = {\Record} x, y: real {\End};            \\
X    {\PB}body = {\Record} m: real; r, v, f: vector {\End};\\
X    {\PB}system = {\Array} [1..n] {\Of} body;             \\
X    {\PB}channel = $*$(body);                             \\
X    {\PB}net = {\Array} [0..p] {\Of} channel;             \\
X    {\PB}mixed = $*$(body, integer);                      \\
X    {\PB}two = {\Array} [0..1] {\Of} mixed;               \\
X    {\PB}four = {\Array} [0..1] {\Of} two;
\end{program}
X
X
\subsection{Channel Types}
X
Processes communicate by means of values called {\it
messages} transmitted through entities called {\it
channels}. A {\it communication} takes place when one
process is ready to {\it output} a message of some type
through a channel and another process is ready to {\it
input} a message of the same type through the same channel.
X
Processes create channels dynamically and access them by
means of values known as {\it channel references}. The type
of a channel reference is called a {\it channel type}.
\blankline
\begin{grammar}
X  {\GA}channel-type =                                 \\
X    {\GB}``$*$'' ``('' message-type-list ``)'' .      \\
X  {\GA}message-type-list =                            \\
X    {\GB}type-identifier \{ ``,'' type-identifier \} .\\
\end{grammar}
X
A channel type
X
\begin{center}
X  $*(T_1,T_2,\ldots,T_n)$
\end{center}
X
\noindent
denotes an unordered set of channel references created
dynamically. Each channel reference denotes a distinct
channel which can transmit messages of distinct types
$T_1,T_2,\ldots,T_n$ only (the {\it message types}).
X
A type definition cannot be of the recursive form:
X
\begin{center}
X  $T = *(\ldots,T,\ldots)$
\end{center}
X
\examples
X
\begin{program}{6.9em}
X  {\PA}$*$(body)         \\
X  {\PA}$*$(body, integer)
\end{program}
X
X
\section{Variables}
X
\subsection{Entire Variables}
X
An {\it entire variable} is a variable denoted by one of the
following kinds of identifiers:
X
\begin{enumerate}
X  \item
X  A variable identifier introduced by a variable declaration
X  or a {\it forall} statement.
X  \item
X  A function identifier that occurs as the left part of an
X  assignment statement in the statement part of the
X  corresponding function block.
\end{enumerate}
X
\examples
X
\blankline
X
The following entire variables are used in the examples of
this paper:
X
\begin{program}{8.9em}
X  {\PA}{\Var}              \\
X    {\PB}inp, out: channel;\\
X    {\PB}c: net;           \\
X    {\PB}a: system;        \\
X    {\PB}ai, aj: body;     \\
X    {\PB}left: mixed;      \\
X    {\PB}top: four;        \\
X    {\PB}i, j, k: integer;
\end{program}
X
A {\it variable context} is associated with each command
$C$. This context consists of two sets of entire variables
called the {\it target} and {\it expression variables} of
$C$. If the process denoted by $C$ may assign a value to an
entire variable $v$ (or one of its components), then $v$ is
a target variable of $C$. If the process may use the value
of $v$ (or one of its components) as an operand, then $v$ is
an expression variable of $C$.
X
X
\subsection{Block Parameters}
X
Consider a procedure or function block $B$ with a statement
part $S$. An {\it implicit parameter} of $B$ is an entire
variable $v$ that is global to $B$ and is part of the
variable context of $S$. If $v$ is a target variable of $S$,
then $v$ is an {\it implicit variable parameter} of $B$. If
$v$ is an expression variable of $S$, then $v$ is an {\it
implicit value parameter} of $B$.
X
A {\it function} block cannot use formal variable parameters
or implicit variable parameters.
X
A {\it recursive procedure} or {\it function} block cannot
use implicit parameters.
X
X
\subsection{Target Variables}
X
An entire variable $v$ is a target variable of a command $C$
in the following cases:
X
\begin{enumerate}
X  \item
X  The variable identifier $v$ occurs in an assignment
X  statement $C$ that denotes assignment to $v$ (or one of
X  its components).
X  \item
X  The variable identifier $v$ occurs in a {\it for}
X  statement $C$ that uses $v$ as the control variable.
X  \item
X  The variable identifier $v$ occurs in a procedure
X  statement $C$  that uses $v$ (or one of its components) as
X  an actual variable parameter.
X  \item
X  The variable $v$ is an implicit variable parameter of a
X  procedure block $B$, and $C$ is a procedure statement that
X  denotes activation of $B$.
X  \item
X  The variable $v$ is a target variable of a command $D$,
X  and $C$ is a structured command that contains $D$.
\end{enumerate}
X
X
\subsection{Expression Variables}
X
An entire variable $v$ is an expression variable of a
command $C$ in the following cases:
X
\begin{enumerate}
X  \item
X  The variable identifier $v$ occurs in an expression $C$
X  that uses $v$ (or one of its components) as an operand.
X  \item
X  The variable identifier $v$ occurs in the element
X  statement $C$ of a {\it forall} statement that introduces
X  $v$ as the index variable.
X  \item
X  The variable $v$ is an implicit value parameter of a
X  function block $B$, and $C$ is a function designator that
X  denotes activation of $B$.
X  \item
X  The variable $v$ is an implicit value parameter of a
X  procedure block $B$, and $C$ is a procedure statement that
X  denotes activation of $B$.
X  \item
X  The variable $v$ is an expression variable of a command
X  $D$, and $C$ is a structured command that contains $D$.
\end{enumerate}
X
X
\subsection{Channel Variables}
X
A {\it channel variable} is a variable of a channel type.
The value of a channel variable is undefined unless a
channel reference has been assigned to the variable.
X
\blankline
X
\begin{grammar}
X  {\GA}channel-variable-access = \\
X    {\GB}variable-access .       \\
\end{grammar}
X
\examples
X
\begin{program}{2.9em}
X  {\PA}inp     \\
X  {\PA}c[0]    \\
X  {\PA}top[i,j]
\end{program}
X
X
\section{Expressions}
X
\subsection{Channel Expressions}
X
\begin{grammar}
X  {\GA}channel-expression =\\
X    {\GB}expression .      \\
\end{grammar}
X
A channel expression is an expression of a channel type. The
expression is said to be {\it well-defined} if it denotes a
channel; otherwise, it is {\it undefined}.
X
\blankline
X
\examples
X
\begin{program}{2.4em}
X  {\PA}out     \\
X  {\PA}c[k$-$1]
\end{program}
X
X
\subsection{Relational Operators}
X
If $x$ and $y$ are well-defined channel expressions of the
same type, the following expressions denote boolean values:
X
\begin{center}
X  x = y{\blank}x $<>$ y
\end{center}
X
The value of x = y is true if $x$ and $y$ denote the same
channel, and is false otherwise. The value of x $<>$ y is
the same as the value of
X
\begin{center}
X  {\Not} (x = y)
\end{center}
X
\example
X
\begin{center}
X  left = top[i,j]
\end{center}
X
X
\section{Message Communication}
X
The required procedures for message communication are
X
\begin{center}
X  open{\blank}send{\blank}receive
\end{center}
X
X
\subsection{The Procedure Open}
X
\begin{grammar}
X  {\GA}open-statement =                              \\
X    {\GB}``{\it open}'' ``('' open-parameters ``)'' .\\
X  {\GA}open-parameters =                             \\
X    {\GB}open-parameter \{ ``,'' open-parameter \} . \\
X  {\GA}open-parameter =                              \\
X    {\GB}channel-variable-access .                   \\
\end{grammar}
X
If $v$ is a channel variable, the statement
X
\begin{center}
X  open(v)
\end{center}
X
\noindent
denotes creation of a new channel.
X
The {\it open} statement is executed by creating a new
channel and assigning the corresponding reference to the
channel variable $v$. The channel reference is of the same
type as the channel variable. The channel exists until the
program execution terminates.
X
The abbreviation  
X
\begin{center}
X  open($v_1,v_2,\ldots,v_n$)
\end{center}
X
\noindent
is equivalent to
X
\begin{center}
X  {\Begin} open($v_1$); open($v_2,\ldots,v_n$) {\End}
\end{center}
X
\examples
X
\begin{program}{6.3em}
X  {\PA}open(c[k])    \\
X  {\PA}open(inp, out)
\end{program}
X
X
\subsection{The Procedures Send and Receive}
X
\begin{grammar}
X  {\GA}send-statement =                                           \\
X    {\GB}``{\it send}'' ``('' send-parameters ``)'' .             \\
X  {\GA}send-parameters =                                          \\
X    {\GB}channel-expression ``,'' output-expression-list .        \\
X  {\GA}output-expression-list =                                   \\
X    {\GB}output-expression \{ ``,'' output-expression \} .        \\
X  {\GA}output-expression =                                        \\
X    {\GB}expression .                                             \\
X  {\GA}receive-statement =                                        \\
X    {\GB}``{\it receive}'' ``('' receive-parameters ``)'' .       \\
X  {\GA}receive-parameters =                                       \\
X    {\GB}channel-expression ``,'' input-variable-list .           \\
X  {\GA}input-variable-list =                                      \\
X    {\GB}input-variable-access \{ ``,'' input-variable-access \} .\\
X  {\GA}input-variable-access =                                    \\
X    {\GB}variable-access .                                        \\
\end{grammar}
X
The statement
X
\begin{center}
X  send(b, e)
\end{center}
X
\noindent
denotes output of the value of an expression $e$ through
the channel denoted by an expression $b$. The expression
$b$ must be of a channel type $T$, and the type of the
expression $e$ must be a message type of $T$.
X
The statement
X
\begin{center}
X  receive(c, v)
\end{center}
X
\noindent
denotes input of the value of a variable $v$ through the
channel denoted by an expression $c$. The expression $c$
must be of a channel type $T$, and the type of the variable
$v$ must be a message type of $T$.
X
The {\it send} and {\it receive} operations defined by the
above statements are said to {\it match} if they satisfy the
following conditions:
X
\begin{enumerate}
X  \item
X  The channel expressions $b$ and $c$ are of the same type
X  $T$ and denote the same channel.
X  \item
X  The output expression $e$ and the input variable $v$ are
X  of the same type, which is a message type of $T$.
\end{enumerate}
X
The execution of a {\it send} operation delays a process
until another process is ready to execute a matching {\it
receive} operation (and vice versa). If and when this
happens, a {\it communication} takes place as follows:
X
\begin{enumerate}
X  \item
X  The sending process obtains a value by evaluating the
X  output expression $e$.
X  \item
X  The receiving process assigns the value to the input
X  variable $v$.
\end{enumerate}
X
After the communication, the sending and receiving processes
proceed independently.
X
\blankline
X
{\it Communication Errors:}
X
\begin{enumerate}
X  \item
X  {\it Undefined channel reference}: A channel expression
X  does not denote a channel.
X  \item
X  {\it Channel contention}: Two parallel processes both
X  attempt to send (or receive) through the same channel at
X  the same time.
X  \item
X  {\it Message type error}: Two parallel processes attempt
X  to communicate through the same channel, but the output
X  expression and the input variable are of different message
X  types.
\end{enumerate}
X
The abbreviation
X
\begin{center}
X  send($b,e_1,e_2,\ldots,e_n$)
\end{center}
X
\noindent
is equivalent to
X
\begin{center}
X  {\Begin} send($b,e_1$); send($b,e_2,\ldots,e_n$) {\End}
\end{center}
X
The abbreviation
X
\begin{center}
X  receive($c,v_1,v_2,\ldots,v_n$)
\end{center}
X
\noindent
is equivalent to
X
\begin{center}
X  {\Begin} receive($c,v_1$); receive($c,v_2,\ldots,v_n$) {\End}
\end{center}
X
\examples
X
\begin{program}{8.1em}
X  {\PA}send(out, ai)        \\
X  {\PA}receive(inp, aj)     \\
X  {\PA}send(top[i,j], 2, ai)
\end{program}
X
X
\section{Statements}
X
\subsection{Assignment Statements}
X
If $x$ is a channel variable access and $y$ is a
well-defined channel expression of the same type, the effect
of the assignment statement
X
\begin{center}
X  x := y
\end{center}
X
\noindent
is to make the values of $x$ and $y$ denote the same
channel.
X
\blankline
X
\example
X
\begin{center}
X  left := top[i,j]
\end{center}
X
X
\subsection{Procedure Statements}
X
The {\it restricted actual parameters} of a procedure
statement are the explicit variable parameters that occur in
the actual parameter list and the implicit parameters of the
corresponding procedure block.
X
\blankline
X
{\it Restriction}: The restricted actual parameters of a
procedure statement must be distinct entire variables (or
components of such variables).
X
\blankline
X
A procedure statement cannot occur in the statement part of
a function block. This rule also applies to a procedure
statement that denotes activation of a required procedure.
X
X
\subsection{Parallel Statements}
X
\begin{grammar}
X  {\GA}parallel-statement =                                 \\
X    {\GB}``{\Parallel}'' process-statement-list ``{\End}'' .\\
X  {\GA}process-statement-list =                             \\
X    {\GB}process-statement \{ ``$|$'' process-statement \} .\\
X  {\GA}process-statement =                                  \\
X    {\GB}statement-sequence .                               \\
\end{grammar}
X
A {\it parallel} statement denotes parallel processes. Each
process is denoted by a separate process statement.
X
The effect of a parallel statement is to execute the process
statements as parallel processes until all of them have
terminated.
X
\blankline
X
{\it Restriction}: In a parallel statement, a target
variable of one process statement cannot be a target or
expression variable of another process statement.
X
\blankline
X
\example
X
\begin{program}{13.6em}
X  {\PA}{\Parallel}                        \\
X    {\PB}source(a, c[0]); sink(a, c[p])$|$\\
X    {\PB}{\Forall} k := 1 {\To} p {\Do}   \\
X      {\PC}node(k, c[k$-$1], c[k])        \\
X  {\PA}{\End}
\end{program}
X
X
\subsection{Forall Statements}
X
\begin{grammar}
X  {\GA}forall-statement =                                  \\
X    {\GB}``{\Forall}'' index-variable-declaration ``{\Do}''\\
X      {\GC}element-statement .                             \\
X  {\GA}index-variable-declaration =                        \\
X    {\GB}variable-identifier ``:='' process-index-range .  \\
X  {\GA}process-index-range =                               \\
X     {\GB}expression ``{\To}'' expression .                \\
X  {\GA}element-statement =                                 \\
X     {\GB}statement .                                      \\
\end{grammar}
X
The statement
X
\begin{center}
X  {\Forall} $i$ := $e_1$ {\To} $e_2$ {\Do} $S$
\end{center}
X
\noindent
denotes a (possibly empty) array of parallel processes,
called {\it element processes}, and a corresponding range of
values, called {\it process indices}. The lower and upper
bounds of the process index range are denoted by two
expressions, $e_1$ and $e_2$, of the same simple type (the
{\it index type}). Every index value corresponds to a
separate element process defined by an {\it index variable
i} and an {\it element statement S}.
X
The {\it index variable declaration}
X
\begin{center}
X  $i$ := $e_1$ {\To} $e_2$
\end{center}
X
\noindent
introduces the index variable $i$ which is local to the
element statement $S$.
X
A {\it forall} statement is executed as follows:
X
\begin{enumerate}
X  \item
X  The expressions $e_1$ and $e_2$ are evaluated. If
X  $e_1 > e_2$, the execution of the {\it forall} statement
X  terminates; otherwise, step 2 takes place.
X  \item
X  $e_2-e_1+1$ element processes run in parallel until all of
X  them have terminated. Each element process creates a local
X  instance of the index variable $i$, assigns the
X  corresponding process index to the variable, and executes
X  the element statement $S$. When an element process
X  terminates, its local instance of the index variable
X  ceases to exist.
\end{enumerate}
X
{\it Restriction}: In a {\it forall} statement, the element
statement cannot use target variables.
X
\blankline
X
\examples
X
\begin{program}{11.8em}
X  {\PA}{\Forall} k := 1 {\To} p {\Do}  \\
X    {\PB}node(k, c[k$-$1], c[k])       \\
X  {\PA}                                \\
X  {\PA}{\Forall} i := 0 {\To} 1 {\Do}  \\
X    {\PB}{\Forall} j := 0 {\To} 1 {\Do}\\
X      {\PC}quadtree(i, j, top[i,j])
\end{program}
X
X
\subsection{Unrestricted Statements}
X
\begin{grammar}
X  {\GA}unrestricted-statement =  \\
X    {\GB}sic-clause statement .  \\
X  {\GA}sic-clause =              \\
X    {\GB}``['' ``{\Sic}'' ``]'' .\\
\end{grammar}
X
A statement $S$ is said to be {\it unrestricted} in the
following cases:
X
\begin{enumerate}
X  \item
X  The statement $S$ is prefixed by a {\it sic} clause.
X  \item
X  The statement $S$ is a component of an unrestricted
X  statement.
\end{enumerate}
X
All other statements are said to be {\it restricted}.
X
Restricted statements must satisfy the rules labeled as
{\it restrictions} in this paper. These rules restrict the
use of entire variables in procedure statements, parallel
statements, and {\it forall} statements to make it possible
to check the disjointness of parallel processes during
single-pass compilation (see 7.2, 7.3 and 7.4).
X
The same rules do {\it not} apply to unrestricted
statements. Consequently, the programmer must prove that
each unrestricted statement preserves the disjointness of
parallel processes; otherwise, the semantics of unrestricted
statements are beyond the scope of this paper.
X
\blankline
X
\examples
X
\begin{program}{14.9em}
X  {\PA}[{\Sic}] \{ i $<>$ j \}                     \\
X    {\PB}swap(a[i], a[j])                          \\
X  {\PA}                                            \\
X  {\PA}[{\Sic}] \{ i $<>$ j \}                     \\
X    {\PB}{\Parallel} a[i] := ai$|$a[j] := aj {\End}\\
X  {\PA}                                            \\
X  {\PA}[{\Sic}] \{ disjoint elements a[i] \}       \\
X    {\PB}{\Forall} i := 1 {\To} n {\Do} a[i] := ai
\end{program}
X
X
\subsection{Assume Statements}
X
\begin{grammar}
X  {\GA}assume-statement =          \\
X    {\GB}``{\Assume}'' assumption .\\
X  {\GA}assumption =                \\
X    {\GB}expression .              \\
\end{grammar}
X
The effect of an {\it assume} statement is to test an
assumption denoted by a boolean expression. If the
assumption is true, the test terminates; otherwise, program
execution stops.
X
\blankline
X
\example
X
\begin{center}
X  {\Assume} i $<>$ j
\end{center}
X
X
\section{SuperPascal versus Pascal}
X
The following summarizes the differences between
{\Superpascal} and Pascal.
X
X
\subsection{Added Features}
X
Table~1 lists the {\Superpascal} features that were added
to Pascal.
X
\begin{table}[p]
X  \caption{Added features}
X  \begin{mytabular}{ll}
X    \hline
X    Language                  & Required   \\
X    concepts                  & identifiers\\
X    \hline
X    channel types             & null       \\
X    structured function types & maxstring  \\
X    parallel statements       & string     \\
X    forall statements         & open       \\
X    unrestricted statements   & send       \\
X    assume statements         & receive    \\
X    \hline
X  \end{mytabular}
\end{table}
X
X
\subsection{Excluded Features}
X
Table~2 lists the Pascal features that were excluded from
{\Superpascal}.
X
\begin{table}[p]
X  \caption{Excluded features}
X  \begin{mytabular}{ll}
X    \hline
X    Language                    & Required   \\
X    concepts                    & identifiers\\
X    \hline
X    labels                      & text       \\
X    subrange types              & input      \\
X    record variants             & output     \\
X    empty field lists           & page       \\
X    set types                   & reset      \\
X    file types                  & get        \\
X    pointer types               & rewrite    \\
X    packed types                & put        \\
X    nameless types              & new        \\
X    renamed types               & dispose    \\
X    functions with side-effects & pack       \\
X    functional parameters       & unpack     \\
X    procedural parameters       &            \\
X    forward declarations        &            \\
X    goto statements             &            \\
X    with statements             &            \\
X    \hline
X  \end{mytabular}
\end{table}
X
X
\subsection{Minor Differences}
X
{\Superpascal} differs from Pascal in the following details:
X
\begin{enumerate}
X  \item
X  {\it Program parameters} are comments only.
X  \item
X  A multi-dimensional {\it array type} is defined in terms
X  of one-dimensional array types.
X  \item
X  The required type {\it string} is the only string type:
X
X  \begin{center}
X    string = {\Array} [1..maxstring] {\Of} char
X  \end{center}
X
X  \noindent
X  A character string with $n$ string elements denotes a
X  string of $n$ characters followed by maxstring$-n$ {\it
X  null} characters, where
X
X  \begin{center}
X     $2\,{\leq}\,n\,{\leq}$ maxstring{\blank}
X     maxstring = 80{\blank}null = chr(0)\\
X  \end{center}
X
X  \noindent
X  The default length $n$ of a write parameter of type string
X  is the number of characters (if any) which precede the
X  first null character (if any), where
X  $0\,{\leq}\,n\,{\leq}$ maxstring.
X  \item
X  The required textfile {\it input} is the only input file.
X  The file identifier is omitted from {\it eof} and {\it
X  eoln} function designators and {\it read} and {\it readln}
X  statements. The input file is an implicit value parameter
X  of the eof and eoln functions and is an implicit variable
X  parameter of the read and readln procedures (see 4.2).
X  \item
X  The required textfile {\it output} is the only output
X  file. The file identifier is omitted from {\it write} and
X  {\it writeln} statements. The output file is an implicit
X  variable parameter of the write and writeln procedures
X  (see 4.2).
\end{enumerate}
X
X
\subsection{Required Identifiers}
X
Table 3 lists the required identifiers of {\Superpascal}.
X
\begin{table}[htb]
X  \caption{Required identifiers}
X  \begin{mytabular}{lll}
X    \hline
X    abs     & maxint    & round  \\
X    arctan  & maxstring & send   \\
X    boolean & null      & sin    \\
X    char    & odd       & sqr    \\
X    chr     & open      & sqrt   \\
X    cos     & ord       & string \\
X    eof     & pred      & succ   \\
X    eoln    & read      & true   \\
X    exp     & readln    & trunc  \\
X    false   & real      & write  \\
X    integer & receive   & writeln\\
X    ln      &           &        \\
X    \hline
X  \end{mytabular}
\end{table}
X
X
\subsection{Syntax Summary}
X
The following grammar defines the complete syntax of
{\Superpascal}.
X
\blankline
X
\begin{grammar}
X  {\GA}program =                                          \\
X    {\GB}program-heading ``;'' program-block ``.'' .      \\
X  {\GA}program-heading =                                  \\
X    {\GB}``{\Program}'' program-identifier
X           [ ``('' program-parameters ``)'' ] .           \\
X  {\GA}program-parameters =                               \\
X    {\GB}parameter-identifier
X           \{ ``,'' parameter-identifier \} .             \\
X  {\GA}program-block =                                    \\
X    {\GB}block .                                          \\
X  {\GA}block =                                            \\
X    {\GB}[ constant-definitions ]
X           [ type-definitions ]                           \\
X      {\GC}[ variable-declarations ]
X             [ routine-declarations ]                     \\
X        {\GD}statement-part .                             \\
X  {\GA}constant-definitions =                             \\
X    {\GB}``{\Const}'' constant-definition ``;''
X            \{ constant-definition ``;'' \} .             \\
X  {\GA}constant-definition =                              \\
X    {\GB}constant-identifier ``='' constant .             \\
X  {\GA}constant =                                         \\
X    {\GB}[ sign ] unsigned-constant .                     \\
X  {\GA}sign =                                             \\
X    {\GB}``+'' $|$ ``$-$'' .                              \\
X  {\GA}type-definitions =                                 \\
X    {\GB}``{\Type}'' type-definition ``;''
X           \{ type-definition ``;'' \} .                  \\
X  {\GA}type-definition =                                  \\
X    {\GB}type-identifier ``='' new-type .                 \\
X  {\GA}new-type =                                         \\
X    {\GB}enumerated-type $|$ array-type $|$
X         record-type $|$ channel-type .                   \\
X  {\GA}enumerated-type =                                  \\
X    {\GB}``('' constant-identifier-list ``)'' .           \\
X  {\GA}constant-identifier-list =                         \\
X    {\GB}constant-identifier
X           \{ ``,'' constant-identifier \} .              \\
X  {\GA}array-type =                                       \\
X    {\GB}``{\Array}'' index-range ``{\Of}''
X           type-identifier .                              \\
X  {\GA}index-range =                                      \\
X    {\GB}``['' constant ``..'' constant ``]'' .           \\
X  {\GA}record-type =                                      \\
X    {\GB}``{\Record}'' field-list ``{\End}'' .            \\
X  {\GA}field-list =                                       \\
X    {\GB}record-section
X           \{ ``;'' record-section \} [ ``;'' ] .         \\
X  {\GA}record-section =                                   \\
X    {\GB}field-identifier-list ``:'' type-identifier .    \\
X  {\GA}field-identifier-list =                            \\
X    {\GB}field-identifier
X           \{ ``,'' field-identifier \} .                 \\
X  {\GA}channel-type =                                     \\
X    {\GB}``$*$'' ``('' message-type-list ``)'' .          \\
X  {\GA}message-type-list =                                \\
X    {\GB}type-identifier \{ ``,'' type-identifier \} .    \\
X  {\GA}variable-declarations =                            \\
X    {\GB}``{\Var}'' variable-declaration ``;''
X           \{ variable-declaration ``;'' \} .             \\
X  {\GA}variable-declaration =                             \\
X    {\GB}variable-identifier-list ``:'' type-identifier . \\
X  {\GA}variable-identifier-list =                         \\
X    {\GB}variable-identifier
X           \{ ``,'' variable-identifier \} .              \\
X  {\GA}routine-declarations =                             \\
X    {\GB}routine-declaration ``;''
X           \{ routine-declaration ``;'' \} .              \\
X  {\GA}routine-declaration =                              \\
X    {\GB}function-declaration $|$ procedure-declaration . \\
X  {\GA}function-declaration =                             \\
X    {\GB}function-heading ``;'' function-block .          \\
X  {\GA}function-heading =                                 \\
X    {\GB}``{\Function}'' function-identifier
X           [ formal-parameter-list ]                      \\
X      {\GC}``:'' type-identifier .                        \\
X  {\GA}formal-parameter-list =                            \\
X    {\GB}``('' formal-parameters ``)'' .                  \\
X  {\GA}formal-parameters =                                \\
X    {\GB}formal-parameter-section
X           \{ ``;'' formal-parameter-section \} .         \\
X  {\GA}formal-parameter-section =                         \\
X    {\GB}[ ``{\Var}'' ] variable-declaration .            \\
X  {\GA}function-block =                                   \\
X    {\GB}block .                                          \\
X  {\GA}procedure-declaration =                            \\
X    {\GB}procedure-heading ``;'' procedure-block .        \\
X  {\GA}procedure-heading =                                \\
X    {\GB}``{\Procedure}'' procedure-identifier
X           [ formal-parameter-list ] .                    \\
X  {\GA}procedure-block =                                  \\
X    {\GB}block .                                          \\
X  {\GA}statement-part =                                   \\
X    {\GB}compound-statement .                             \\
X  {\GA}compound-statement =                               \\
X    {\GB}``{\Begin}'' statement-sequence ``{\End}'' .     \\
X  {\GA}statement-sequence =                               \\
X    {\GB}statement \{ ``;'' statement \} .                \\
X  {\GA}statement =                                        \\
X    {\GB}empty-statement $|$ assignment-statement $|$     \\
X    {\GB}procedure-statement $|$ if-statement $|$         \\
X    {\GB}while-statement $|$ repeat-statement $|$         \\
X    {\GB}for-statement $|$ case-statement $|$             \\
X    {\GB}compound-statement $|$ parallel-statement $|$    \\
X    {\GB}forall-statement $|$ unrestricted-statement $|$  \\
X    {\GB}assume-statement .                               \\
X  {\GA}empty-statement = .                                \\
X  {\GA}assignment-statement =                             \\
X    {\GB}left-part ``:='' expression .                    \\
X  {\GA}left-part =                                        \\
X    {\GB}variable-access $|$ function-identifier .        \\
X  {\GA}procedure-statement =                              \\
X    {\GB}procedure-identifier [ actual-parameter-list ] . \\
X  {\GA}actual-parameter-list =                            \\
X    {\GB}``('' actual-parameters ``)'' .                  \\
X  {\GA}actual-parameters =                                \\
X    {\GB}actual-parameter \{ ``,'' actual-parameter \} .  \\
X  {\GA}actual-parameter =                                 \\
X    {\GB}expression $|$ variable-access $|$
X         write-parameter .                                \\
X  {\GA}write-parameter =                                  \\
X    {\GB}expression
X           [ ``:'' expression [ ``:'' expression ] ] .    \\
X  {\GA}if-statement =                                     \\
X    {\GB}``{\If}'' expression ``{\Then}'' statement       \\
X      {\GC}[ ``{\Else}'' statement ] .                    \\
X  {\GA}while-statement =                                  \\
X    {\GB}``{\While}'' expression ``{\Do}'' statement .    \\
X  {\GA}repeat-statement =                                 \\
X    {\GB}``{\Repeat}'' statement-sequence
X           ``{\Until}'' expression .                      \\
X  {\GA}for-statement =                                    \\
X    {\GB}``{\For}'' control-variable ``:='' expression    \\
X      {\GC}( ``{\To}'' $|$ ``{\Downto}'' ) expression
X             ``{\Do}'' statement .                        \\
X  {\GA}control-variable =                                 \\
X    {\GB}entire-variable .                                \\
X  {\GA}case-statement =                                   \\
X    {\GB}``{\Case}'' expression ``{\Of}''
X           case-list ``{\End}'' .                         \\
X  {\GA}case-list =                                        \\
X    {\GB}case-list-element \{ ``;'' case-list-element \}
X           [ ``;'' ] .                                    \\
X  {\GA}case-list-element =                                \\
X    {\GB}case-constant \{ ``,'' case-constant \}
X           ``:'' statement .                              \\
X  {\GA}case-constant =                                    \\
X    {\GB}constant .                                       \\
X  {\GA}parallel-statement =                               \\
X    {\GB}``{\Parallel}'' process-statement-list
X           ``{\End}'' .                                   \\
X  {\GA}process-statement-list =                           \\
X    {\GB}process-statement
X           \{ ``$|$'' process-statement \} .              \\
X  {\GA}process-statement =                                \\
X    {\GB}statement-sequence .                             \\
X  {\GA}forall-statement =                                 \\
X    {\GB}``{\Forall}'' index-variable-declaration
X         ``{\Do}''                                        \\
X      {\GC}element-statement .                            \\
X  {\GA}index-variable-declaration =                       \\
X    {\GB}variable-identifier ``:='' process-index-range . \\
X  {\GA}process-index-range =                              \\
X    {\GB}expression ``{\To}'' expression .                \\
X  {\GA}element-statement =                                \\
X    {\GB}statement .                                      \\
X  {\GA}unrestricted-statement =                           \\
X    {\GB}``['' ``{\Sic}'' ``]'' statement .               \\
X  {\GA}assume-statement =                                 \\
X    {\GB}``{\Assume}'' expression .                       \\
X  {\GA}expression =                                       \\
X    {\GB}simple-expression                                \\
X      {\GC}[ relational-operator simple-expression ] .    \\
X  {\GA}relational-operator =                              \\
X    {\GB}``$<$'' $|$ ``='' $|$ ``$>$'' $|$
X         ``$<=$'' $|$ ``$<>$'' $|$ ``$>=$'' .             \\
X  {\GA}simple-expression =                                \\
X    {\GB}[ sign ] term \{ adding-operator term \} .       \\
X  {\GA}adding-operator =                                  \\
X    {\GB}``+'' $|$ ``$-$'' $|$ ``{\Or}'' .                \\
X  {\GA}term =                                             \\
X    {\GB}factor \{ multiplying-operator factor \} .       \\
X  {\GA}multiplying-operator =                             \\
X    {\GB}``$*$'' $|$ ``/'' $|$ ``{\Div}'' $|$
X         ``{\Mod}'' $|$ ``{\And}'' .                      \\
X  {\GA}factor =                                           \\
X    {\GB}function-designator $|$ variable-access $|$      \\
X    {\GB}unsigned-constant $|$ ``('' expression ``)'' $|$ \\
X    {\GB}``{\Not}'' factor .                              \\
X  {\GA}function-designator =                              \\
X    {\GB}function-identifier [ actual-parameter-list ] .  \\
X  {\GA}variable-access =                                  \\
X    {\GB}entire-variable \{ component-selector \} .       \\
X  {\GA}entire-variable =                                  \\
X    {\GB}variable-identifier .                            \\
X  {\GA}component-selector =                               \\
X    {\GB}field-selector $|$ indexed-selector .            \\
X  {\GA}field-selector =                                   \\
X    {\GB}``.'' field-identifier .                         \\
X  {\GA}indexed-selector =                                 \\
X    {\GB}``['' index-expressions ``]'' .                  \\
X  {\GA}index-expressions =                                \\
X    {\GB}expression \{ ``,'' expression \} .              \\
X  {\GA}unsigned-constant =                                \\
X    {\GB}character-string $|$ unsigned-real $|$           \\
X    {\GB}unsigned-integer $|$ constant-identifier .       \\
X  {\GA}character-string =                                 \\
X    {\GB}``\,'\,'' string-elements ``\,'\,'' .            \\
X  {\GA}string-elements =                                  \\
X    {\GB}string-element \{ string-element \} .            \\
X  {\GA}string-element =                                   \\
X    {\GB}string-character $|$ apostrophe-image .          \\
X  {\GA}apostrophe-image =                                 \\
X    {\GB}``\,''\,'' .                                     \\
X  {\GA}unsigned-real =                                    \\
X    {\GB}unsigned-integer real-option .                   \\
X  {\GA}real-option =                                      \\
X    {\GB}``.'' fractional-part [ scaling-part ] $|$
X         scaling-part .                                   \\
X  {\GA}fractional-part =                                  \\
X    {\GB}digit-sequence .                                 \\
X  {\GA}scaling-part =                                     \\
X    {\GB}``e'' scale-factor .                             \\
X  {\GA}scale-factor =                                     \\
X    {\GB}[ sign ] unsigned-integer .                      \\
X  {\GA}unsigned-integer =                                 \\
X    {\GB}digit-sequence .                                 \\
X  {\GA}digit-sequence =                                   \\
X    {\GB}digit \{ digit \} .                              \\
X  {\GA}identifier =                                       \\
X    {\GB}letter \{ letter $|$ digit \} .                  \\
\end{grammar}
X
X
\acknowledgements
X
I thank Jonathan Greenfield and Peter O'Hearn for their
helpful comments.
X
X
\begin{mybibliography}{3}
X  \entry
X  IEEE (1983). {\it IEEE Standard Pascal Computer
X  Programming Language}. Institute of Electrical and
X  Electronics Engineers, New York, NY.
X  \entry
X  Brinch Hansen, P. (1993a) SuperPascal---a publication
X  language for parallel scientific computing. School of
X  Computer and Information Science, Syracuse University,
X  Syracuse, NY.
X  \entry
X  Brinch Hansen, P. (1993b) Interference control in
X  SuperPascal---a block-structured parallel language.
X  School of Computer and Information Science, Syracuse
X  Syracuse University, Syracuse, NY.
\end{mybibliography}
X
\end{document}
SHAR_EOF
  $shar_touch -am 1029021698 'report.tex' &&
  chmod 0600 'report.tex' ||
  $echo 'restore of' 'report.tex' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'report.tex:' 'MD5 check failed'
825432a513f9c2c7d9b8f364731c1f3d  report.tex
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'report.tex'`"
    test 45071 -eq "$shar_count" ||
    $echo 'report.tex:' 'original size' '45071,' 'current size' "$shar_count!"
  fi
fi
# ============= user.tex ==============
if test -f 'user.tex' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'user.tex' '(file already exists)'
else
  $echo 'x -' extracting 'user.tex' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'user.tex' &&
%         THE SUPERPASCAL USER MANUAL
%              PER BRINCH HANSEN
%  School of Computer and Information Science
% Syracuse University, Syracuse, NY 13244, USA
%               28 October 1993
%     Copyright(c) 1993 Per Brinch Hansen
X
% LATEX PREAMBLE
\documentstyle[twoside,11pt]{article}
\pagestyle{myheadings}
\setlength{\topmargin}{7mm}
\setlength{\textheight}{200mm}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{14mm}
\setlength{\evensidemargin}{12mm}
\newcommand{\acknowledgements}
X  {\section*{Acknowledgements}
X   \addcontentsline{toc}{section}
X     {Acknowledgements}
X  }
\newcommand{\blank}
X  {\mbox{\hspace{1.8em}}}
\newcommand{\blankline}
X  {\medskip}
\newcommand{\Copyright}
X  {Copyright {\copyright}}
\newcommand{\entry}
X  {\bibitem{}}
\newcommand{\example}
X  {{\it Example:}}
\newcommand{\examples}
X  {{\it Examples:}}
\newcommand{\mytitle}[3]
% [title,month,year]
X  {\markboth{Per Brinch Hansen}{#1}
X   \thispagestyle{empty}
X   \begin{center}
X     {\Large\bf #1}\\
X     % TITLE    
X     \blankline
X       PER BRINCH HANSEN
X     \footnote{
X       \Copyright #3 % Year
X       Per Brinch Hansen. All rights reserved.}\\
X     \blankline
X     {\it
X       School of Computer and Information Science  \\
X       Syracuse University, Syracuse, NY 13244, USA\\
X     }
X     \blankline
X     #2 #3\\
X     %  Month Year
X   \end{center}
X  }
\newcommand{\Superpascal}
X  {\it SuperPascal}
\newenvironment{grammar}
X  {\begin{small}}
X  {\end{small}}
\newenvironment{myabstract}
X  {\begin{rm}
X     \noindent{\bf Abstract:}}
X  {\end{rm}}
\newenvironment{mybibliography}[1]
% [widestlabel]
X  {\begin{small}
X    \begin{thebibliography}{#1}
X      \addcontentsline{toc}
X        {section}{References}}
X  {  \end{thebibliography}
X   \end{small}}
\newenvironment{mykeywords}
X  {\begin{small}
X     \noindent{\bf Key Words:}}
X  {\end{small}}
\newenvironment{mytabular}[1]
% [columns]
X  {\begin{small}
X     \begin{center}
X       \begin{tabular}{#1}}
X  {    \end{tabular}
X     \end{center}
X   \end{small}}
\newenvironment{program}[1]
% [width]
X  {\begin{center}
X     \begin{minipage}{#1}}
X  {  \end{minipage}
X   \end{center}}
% Program Indentation
\newcommand{\PA}
X  {\noindent}
\newcommand{\PB}
X  {\mbox{\hspace{1em}}}
\newcommand{\PC}
X  {\mbox{\hspace{2em}}}
\newcommand{\PD}
X  {\mbox{\hspace{3em}}}
\newcommand{\PE}
X  {\mbox{\hspace{4em}}}
X
% DOCUMENT TEXT
\begin{document}
X
\mytitle{The SuperPascal User Manual}
X  {November}{1993}
X
\begin{myabstract}
X  This report explains how you compile and run {\Superpascal}
X  programs [Brinch Hansen 1993a].
\end{myabstract}
X
X
\section{Command Aliases}
X
If you are using {\Superpascal} under Unix, please define the
following command aliases in the file .{\it cshrc} in your
home directory:
X
\begin{program}{23.5em}
X  {\PA}alias sc $<${\it path name of an executable compiler sc}$>$   \\
X  {\PA}alias sr $<${\it path name of an executable interpreter sr}$>$\\
\end{program}
X
X
\section{Program Compilation}
X
You compile a {\Superpascal} program by typing the command
X
\begin{center}
X  {\it sc}
\end{center}
X
\noindent
followed by a return. When the message
X
\begin{center}
X  source =
\end{center}
X
\noindent
appears, type the name of a program textfile followed by a
return. After the message
X
\begin{center}
X  code =
\end{center}
X
\noindent
type the name of a new program codefile followed by a
return.
X
\blankline
X
\example
X
\begin{program}{10.5em}
X  {\PA}{\it sc}                    \\
X    {\PB}source = {\it sortprogram}\\
X    {\PB}code = {\it sortcode}     \\
\end{program}
X
If the compiler finds errors in a program text, the errors
are reported both on the screen and in the textfile {\it
errors}, but no program code is output.
X
X
\section{Program Execution}
X
You run a compiled {\Superpascal} program by typing the
command
X
\begin{center}
X  {\it sr}
\end{center}
X
\noindent
followed by a return. When the message
X
\begin{center}
X  code =
\end{center}
X
\noindent
appears, type the name of a program codefile followed by a
return. After the message
X
\begin{center}
X  select files?
\end{center}
X
\noindent
you have a choice:
X
\blankline
X
1.~If you type {\it no} followed by a return, the program
will be executed with text input from the {\it keyboard}
and text output on the {\it screen}.
X
\blankline
X
2.~If you type {\it yes} followed by a return, you will
first be asked to name the input file:
X
\begin{center}
X  input =
\end{center}
X
\noindent
Type the name of an existing textfile or the word {\it
keyboard} followed by a return. Finally, you will be asked
to name the output:
X
\begin{center}
X  output =
\end{center}
X
\noindent
Type the name of a new textfile or the word {\it screen}
followed by a return.
X
\blankline
X
\examples
X
\begin{program}{8.1em}
X  {\PA}{\it sr}                 \\
X    {\PB}code = {\it sortcode}  \\
X    {\PB}select files? {\it no} \\
X  {\PA}                         \\
X  {\PA}{\it sr}                 \\
X    {\PB}code = {\it sortcode}  \\
X    {\PB}select files? {\it yes}\\
X    {\PB}input = {\it testdata} \\
X    {\PB}output = {\it screen}  \\
\end{program}
X
X
\section{Compile-time Errors}
X
During compilation, the following program errors are
reported:
X
\begin{itemize}
X  \item
X  {\it Ambiguous case constant:} Two case constants denote
X  the same value.
X  \item
X  {\it Ambiguous identifier:} A program, a function
X  declaration, a procedure declaration, or a record type
X  introduces two named entities with the same identifier.
X  \item
X  {\it Forall statement error:} In a restricted {\it forall}
X  statement, the element statement uses a target variable.
X  \item
X  {\it Function block error:} A procedure statement occurs
X  in the statement part of a function block.
X  \item
X  {\it Function parameter error:} A function uses an
X  explicit or implicit variable parameter.
X  \item
X  {\it Identifier kind error:} A named entity of the wrong
X  kind is used in some context. (Constants, types, fields,
X  variables, functions and procedures are different kinds of
X  named entities.)
X  \item
X  {\it Incomplete comment:} The closing delimiter \} of a
X  comment is missing.
X  \item
X  {\it Index range error:} The index range of an array type
X  has a lower bound that exceeds the upper bound.
X  \item
X  {\it Number error:} A constant denotes a number outside
X  the range of integers or reals.
X  \item
X  {\it Parallel statement error:} In a restricted parallel
X  statement, a target variable of one process statement is
X  also a target or an expression variable of another process
X  statement.
X  \item
X  {\it Procedure statement error:} In a restricted procedure
X  statement, an entire variable is used more than once as a
X  restricted actual parameter.
X  \item
X  {\it Recursion error:} A recursive function or procedure
X  uses an implicit parameter.
X  \item
X  {\it Syntax error:} The program syntax is incorrect.
X  \item
X  {\it Type error:} The type of an operand is incompatible
X  with its use.
X  \item
X  {\it Undefined identifier:} An identifier is used without
X  being defined.
\end{itemize}
X
X
\section{Run-time Errors}
X
During program execution, the following program errors are
reported:
X
\begin{itemize}
X  \item
X  {\it Channel contention:} Two processes both attemp to
X  send or receive through the same channel.
X  \item
X  {\it Deadlock:} Every process is delayed by a send or
X  receive operation, but none of these operations match.
X  \item
X  {\it False assumption:} An assume statement denotes a
X  false assumption.
X  \item
X  {\it Message type error}: Two processes attempt to
X  communicate through the same channel, but the output
X  expression and the input variable are of different message
X  types.
X  \item
X  {\it Range error:} The value of an index expression or a
X  {\it chr, pred,} or {\it succ} function designator is out
X  of range.
X  \item
X  {\it Undefined case constant:} A case expression does not
X  denote a case constant.
X  \item
X  {\it Undefined channel reference:} A channel expression
X  does not denote a channel.
\end{itemize}
X
X
\section{Software Limits}
X
If a program is too large to be compiled or run, the software
displays one of the following messages and stops. Each
message indicates that the limit of a particular software
array type has been exceeded:
X
\begin{itemize}
X  \item
X  {\it Block limit exceeded:} The total number of blocks
X  defined by the program and its function declarations,
X  procedure declarations, {\it forall} statements, and
X  process statements exceeds the limit {\it maxblock}.
X  \item
X  {\it Branch limit exceeded:} The total number of branches
X  denoted by all statements in the program exceeds the limit
X  {\it maxlabel}.
X  \item
X  {\it Buffer limit exceeded:} The size of the compiled code
X  exceeds the limit {\it maxbuf}.
X  \item
X  {\it Case limit exceeded:} The number of case constants
X  exceeds the limit {\it maxcase}.
X  \item
X  {\it Channel limit exceeded:} The number of channels
X  opened exceeds the limit {\it maxchan}.
X  \item
X  {\it Character limit exceeded:} The total number of
X  characters in all word symbols and identifiers exceeds the
X  limit {\it maxchar}.
X  \item
X  {\it Memory limit exceeded:} The program execution exceeds
X  the limit {\it maxaddr}.
X  \item
X  {\it Nesting limit exceeded:} The level of nesting of the
X  program and its function declarations, procedure
X  declarations, parallel statements, and {\it forall}
X  statements exceeds the limit {\it maxlevel}.
X  \item
X  {\it String limit exceeded:} The number of characters in a
X  word symbol, an identifier, or a character string exceeds
X  the limit {\it maxstring}.
\end{itemize}
X
The standard {\it software limits} are:
X
\begin{mytabular}{llrllr}
X  maxaddr  & = & 100000 & maxchar   & = & 10000 \\
X  maxblock & = &    200 & maxlabel  & = &  1000 \\
X  maxbuf   & = &  10000 & maxlevel  & = &    10 \\
X  maxcase  & = &    128 & maxstring & = &    80 \\
X  maxchan  & = &  10000 &           &   &       \\
\end{mytabular}
X
If these limits are too small for compilation or execution of
a program, the limits must be increased by editing a common
declaration file and recompiling both the compiler and the
interpreter [Brinch Hansen 1993b].
X
\begin{mybibliography}{2}
X  \entry
X  Brinch Hansen, P. (1993a) The programming language
X  SuperPascal. School of Computer and Information Science,
X  Syracuse University, Syracuse, NY.
X  \entry
X  Brinch Hansen, P. (1993b) The SuperPascal software notes.
X  School of Computer and Information Science, Syracuse
X  University, Syracuse, NY.
\end{mybibliography}
X
\end{document}
SHAR_EOF
  $shar_touch -am 1029021698 'user.tex' &&
  chmod 0600 'user.tex' ||
  $echo 'restore of' 'user.tex' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'user.tex:' 'MD5 check failed'
ec61f55a22b9533d7aa89c4de9af0f93  user.tex
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'user.tex'`"
    test 10425 -eq "$shar_count" ||
    $echo 'user.tex:' 'original size' '10425,' 'current size' "$shar_count!"
  fi
fi
# ============= notes.tex ==============
if test -f 'notes.tex' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'notes.tex' '(file already exists)'
else
  $echo 'x -' extracting 'notes.tex' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'notes.tex' &&
%        THE SUPERPASCAL SOFTWARE NOTES
%              PER BRINCH HANSEN
%  School of Computer and Information Science
% Syracuse University, Syracuse, NY 13244, USA
%               29 October 1993
%     Copyright(c) 1993 Per Brinch Hansen
X
% LATEX PREAMBLE
\documentstyle[twoside,11pt]{article}
\pagestyle{myheadings}
\setlength{\topmargin}{7mm}
\setlength{\textheight}{200mm}
\setlength{\textwidth}{140mm}
\setlength{\oddsidemargin}{14mm}
\setlength{\evensidemargin}{12mm}
\newcommand{\acknowledgements}
X  {\section*{Acknowledgements}
X   \addcontentsline{toc}{section}
X     {Acknowledgements}
X  }
\newcommand{\blank}
X  {\mbox{\hspace{1.8em}}}
\newcommand{\blankline}
X  {\medskip}
\newcommand{\Copyright}
X  {Copyright {\copyright}}
\newcommand{\entry}
X  {\bibitem{}}
\newcommand{\example}
X  {{\it Example:}}
\newcommand{\examples}
X  {{\it Examples:}}
\newcommand{\mytitle}[3]
% [title,month,year]
X  {\markboth{Per Brinch Hansen}{#1}
X   \thispagestyle{empty}
X   \begin{center}
X     {\Large\bf #1}\\
X     % TITLE    
X     \blankline
X       PER BRINCH HANSEN
X     \footnote{
X       \Copyright #3 % Year
X       Per Brinch Hansen. All rights reserved.}\\
X     \blankline
X     {\it
X       School of Computer and Information Science  \\
X       Syracuse University, Syracuse, NY 13244, USA\\
X     }
X     \blankline
X     #2 #3\\
X     %  Month Year
X   \end{center}
X  }
\newcommand{\Superpascal}
X  {\it SuperPascal}
\newenvironment{grammar}
X  {\begin{small}}
X  {\end{small}}
\newenvironment{myabstract}
X  {\begin{rm}
X     \noindent{\bf Abstract:}}
X  {\end{rm}}
\newenvironment{mybibliography}[1]
% [widestlabel]
X  {\begin{small}
X    \begin{thebibliography}{#1}
X      \addcontentsline{toc}
X        {section}{References}}
X  {  \end{thebibliography}
X   \end{small}}
\newenvironment{mykeywords}
X  {\begin{small}
X     \noindent{\bf Key Words:}}
X  {\end{small}}
\newenvironment{mytabular}[1]
% [columns]
X  {\begin{small}
X     \begin{center}
X       \begin{tabular}{#1}}
X  {    \end{tabular}
X     \end{center}
X   \end{small}}
\newenvironment{program}[1]
% [width]
X  {\begin{center}
X     \begin{minipage}{#1}}
X  {  \end{minipage}
X   \end{center}}
% Program Indentation
\newcommand{\PA}
X  {\noindent}
\newcommand{\PB}
X  {\mbox{\hspace{1em}}}
\newcommand{\PC}
X  {\mbox{\hspace{2em}}}
\newcommand{\PD}
X  {\mbox{\hspace{3em}}}
\newcommand{\PE}
X  {\mbox{\hspace{4em}}}
X
% DOCUMENT TEXT
\begin{document}
X
\mytitle{The SuperPascal Software Notes}
X  {November}{1993}
X
\begin{myabstract}
X  These notes describe the {\Superpascal} software, define
X  the terms and conditions for its use, and explain how
X  you compile the {\Superpascal} compiler and interpreter.
\end{myabstract}
X
X
\section{Definitions}
X
\subsection{Software}
X
The {\it SuperPascal} software (hereafter {\it Software}) is
educational software written by Per Brinch Hansen (hereafter
{\it PBH}). The {\it Software} consists of the {\it Manuals},
{\it Programs}, and {\it Scripts} for the programming
language {\Superpascal} invented by {\it PBH}. The {\it
Software} is stored as text in 11 files (hereafter {\it Files}).
X
X
\subsection{Manuals}
X
The {\it Manuals}, written by {\it PBH}, are stored as {\LaTeX}
text in 3 {\it Files}:
X
\begin{itemize}
X  \item
X  {\it report.tex:} ``The programming language SuperPascal''
X  [Brinch Hansen 1993a].
X  \item
X  {\it user.tex:} ``The SuperPascal user manual'' [Brinch
X  Hansen 1993b].
X  \item
X  {\it notes.tex:} ``The SuperPascal software notes'' [The
X  present notes].
\end{itemize}
X
X
\subsection{Programs}
X
The {\it Programs}, written by {\it PBH}, are a {\Superpascal}
compiler and interpreter (hereafter {\it Compiler} and {\it
Interpreter}). The {\it Programs} are based on the Pascal
compiler and interpreter described and listed in [Brinch
Hansen 1985]. The {\it Programs} are written in Pascal for
Sun3 and Sun4 workstations running Unix.
X
The {\it Programs} are stored as Pascal text in 6 {\it Files}
(hereafter {\it Program Files}):
X
\begin{itemize}
X  \item
X  {\it common.p:} The common declarations used by the
X  {\it Compiler} and {\it Interpreter}.
X  \item
X  {\it scan.p:} The {\it Compiler} procedure that performs
X  lexical analysis.
X  \item
X  {\it parse.p:} The {\it Compiler} procedure that performs
X  syntax, scope, and type analysis.
X  \item
X  {\it assemble.p:} The {\it Compiler} procedure that
X  assembles interpreted code.
X  \item
X  {\it compile.p:} The {\it Compiler} program.
X  \item
X  {\it interpret.p:} The {\it Interpreter} program.
\end{itemize}
X
X
\subsection{Scripts}
X
The {\it Scripts} are Unix shell scripts stored as text in 2
{\it Files}:
X
\begin{itemize}
X  \item
X  {\it sun3.user:} A shell script for compilation of the
X  {\it Programs} on a Sun3 workstation under Unix.
X  \item
X  {\it sun4.user:} A shell script for compilation of the
X  {\it Programs} on a Sun4 workstation under Unix.
\end{itemize}
X
X
\section{Terms and Conditions}
X
\begin{it}
X  THE MANUALS ARE COPYRIGHTED BY PBH. THE PROGRAMS ARE IN THE
X  PUBLIC DOMAIN. YOU CAN OBTAIN THE SOFTWARE BY ANONYMOUS FTP.
X  THE SOFTWARE IS NOT GUARANTEED FOR A PARTICULAR PURPOSE. PBH
X  SUPPLIES THE SOFTWARE ``AS IS'' WITHOUT ANY WARRANTIES OR
X  REPRESENTATIONS AND DOES NOT ACCEPT ANY LIABILITIES WITH
X  RESPECT TO THE SOFTWARE.
X  YOU (THE USER) ARE RESPONSIBLE FOR SELECTING THE SOFTWARE, AND
X  FOR THE USE AND RESULTS OBTAINED FROM THE SOFTWARE. YOUR USE
X  OF THE SOFTWARE INDICATES YOUR ACCEPTANCE OF THESE TERMS AND
X  CONDITIONS.
\end{it}
X
X
\section{Software Limits}
X
The {\it Program File common.p} (hereafter {\it Common
Declarations}) defines common constants, types, functions, and
procedures used by the {\it Programs}. The limits of software
arrays are defined by common constants (hereafter {\it Software
Limits}). If the {\it Software Limits} are too small for
compilation or execution of a user program, these limits must
be increased by editing the {\it Common Declarations} and
recompiling the {\it Programs}.
X
X
\section{Include Commands}
X
The {\it Program File compile.p} contains the following {\it
include commands}:
X
\begin{program}{10.0em}
X  {\PA}{\#}include "common.p"  \\
X  {\PA}{\#}include "scan.p"    \\
X  {\PA}{\#}include "parse.p"   \\
X  {\PA}{\#}include "assemble.p"\\
\end{program}
X
These commands ensure that Pascal compilation of the {\it
Compiler} also includes the {\it Common Declarations} and
the {\it Compiler} procedures.
X
The {\it Program File interpret.p} contains the {\it
include} command:
X
\begin{center}
X  {\#}include "common.p"
\end{center}
X
This command ensures that Pascal compilation of the
{\it Interpreter} also includes the {\it Common
Declarations}.
X
X
\section{Nonstandard Pascal}
X
The {\it Programs} use the following nonstandard
statements, which are Sun extensions of Pascal [Sun
Microsystems 1986]:
X
\begin{mytabular}{lll}
X  \hline
X  Program File & Procedure  & Nonstandard statement     \\
X  \hline
X  compile.p    & testoutput & rewrite(log, kind)        \\
X  compile.p    & codeoutput & rewrite(code, codename)   \\
X  compile.p    & firstpass  & rewrite(errors, errorfile)\\
X  compile.p    & firstpass  & reset(source, sourcename) \\
X  interpret.p  & readtime   & t := clock                \\
X  interpret.p  & openoutput & rewrite(outfile, outname) \\
X  interpret.p  & openinput  & reset(inpfile, inpname)   \\
X  interpret.p  & start      & reset(codefile, codename) \\
X  \hline
\end{mytabular}
X
The rest of the {\it Program Files} conform to {\it ISO
Level 1 Standard Pascal} [British Standards Institute 1982].
X
X
\section{Program Compilation}
X
When you have obtained the {\it Files}, the first step is
is to compile the {\it Programs}.
X
On a {\it Sun3} you compile the {\it Programs} by typing the
Unix command:
X
\begin{center}
X  csh sun3.user
\end{center}
X
The {\it Script sun3.user} contains the Unix commands:
X
\begin{program}{16.7em}
X  {\PA}echo Compiling Sun3 SuperPascal           \\
X  {\PA}pc --s --H --O --f68881 --o sc compile.p  \\
X  {\PA}pc --s --H --O --f68881 --o sr interpret.p\\
\end{program}
X
The {\it Programs} are compiled with the following Sun3
options:
X
\begin{itemize}
X  \item
X  {\it --s:} Check the Pascal standard.
X  \item
X  {\it --H:} Check pointers (but not subranges).
X  \item
X  {\it --O:} Optimize the code.
X  \item
X  {\it --f68881:} Generate code for the Motorola 68881
X  floating-point processor.
\end{itemize}
X
On a {\it Sun4} you compile the {\it Programs} by typing
the Unix command:
X
\begin{center}
X  csh sun4.user
\end{center}
X
The {\it Script sun4.user} contains the Unix commands:
X
\begin{program}{15.7em}
X  {\PA}echo Compiling Sun4 SuperPascal         \\
X  {\PA}pc --s --H --O --cg89 --o sc compile.p  \\
X  {\PA}pc --s --H --O --cg89 --o sr interpret.p\\
\end{program}
X
The {\it Programs} are compiled with the following Sun4
options:
X
\begin{itemize}
X  \item
X  {\it --s:} Check the Pascal standard.
X  \item
X  {\it --H:} Check pointers (but not subranges).
X  \item
X  {\it --O:} Optimize the code.
X  \item
X  {\it --cg89:} Generate code for any Sun4.
\end{itemize}
X
The {\it --s} option causes the Sun Pascal compilers to
display warning mesages about the nonstandard Pascal
statements used in the {\it Programs}.
X
A compilation of the {\it Programs} takes 3--5 minutes
and produces two {\it Executable Files} [Brinch Hansen
1993b]:
X
\begin{itemize}
X  \item
X  {\it sc:} An executable {\it Compiler}.
X  \item
X  {\it sr:} An executable {\it Interpreter}.
\end{itemize}
X
If you are not using {\Superpascal} on a Sun3 or Sun4, try
the following if the {\it Programs} cannot be compiled
directly:
X
\begin{itemize}
X  \item
X  Change or omit the compilation options in the {\it
X  Scripts}.
X  \item
X  Change or omit the nonstandard statements in the
X  {\it Program Files}.
X  \item
X  Include the {\it Common Declarations} in each of the
X  other {\it Program Files}. These {\it Program Files}
X  can then be compiled separately and linked together.
\end{itemize}
X
X
\begin{mybibliography}{5}
X  \entry
X  Brinch Hansen, P. (1985) {\it Brinch Hansen on Pascal
X  Compilers.} Prentice-Hall, Englewood Cliffs, NJ.
X  \entry
X  Brinch Hansen, P. (1993a) The programming language
X  SuperPascal. School of Computer and Information Science,
X  Syracuse University, Syracuse, NY.
X  \entry
X  Brinch Hansen, P. (1993b) The SuperPascal user manual.
X  School of Computer and Information Science, Syracuse
X  University, Syracuse, NY.
X  \entry
X  British Standards Institute (1982) {\it Specification
X  for Computer Programming Language Pascal.} BS 6192.
X  \entry
X  Sun Microsystems (1986) {\it Pascal Programmer's Guide.}
X  Mountain View, CA.
\end{mybibliography}
X
\end{document}
SHAR_EOF
  $shar_touch -am 1029021698 'notes.tex' &&
  chmod 0600 'notes.tex' ||
  $echo 'restore of' 'notes.tex' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'notes.tex:' 'MD5 check failed'
02b5199592890530af7fb8bfbeb3831c  notes.tex
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'notes.tex'`"
    test 10504 -eq "$shar_count" ||
    $echo 'notes.tex:' 'original size' '10504,' 'current size' "$shar_count!"
  fi
fi
# ============= common.p ==============
if test -f 'common.p' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'common.p' '(file already exists)'
else
  $echo 'x -' extracting 'common.p' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'common.p' &&
{ SUPERPASCAL COMPILER AND INTERPRETER
X             COMMON BLOCK
X            3 Novemver 1993
X  Copyright (c) 1993 Per Brinch Hansen }
X
const
X  { compilation options }
X
X  testoptions = false;
X  restricted = true;
X
X  { software limits }
X
X  maxaddr = 100000; maxblock = 200;
X  maxbuf = 10000; maxcase = 128;
X  maxchan = 10000; maxchar = 10000;
X  maxlabel = 1000; maxlevel = 10;
X  maxphrase = 30; maxstring = 80;
X  minreal = 1.0e-307;
X  maxreal = 1.0e+307;
X
X  { standard identifiers }
X
X  minstandard = 1;
X  maxstandard = 34;
X  abs0 = 1; arctan0 = 2;
X  boolean0 = 3; char0 = 4;
X  chr0 = 5; cos0 = 6;
X  eof0 = 7; eoln0 = 8;
X  exp0 = 9; false0 = 10;
X  integer0 = 11; ln0 = 12;
X  maxint0 = 13; maxstring0 = 14;
X  null0 = 15; odd0 = 16;
X  open0 = 17; ord0 = 18;
X  pred0 = 19; read0 = 20;
X  readln0 = 21; real0 = 22;
X  receive0 = 23; round0 = 24;
X  send0 = 25; sin0 = 26;
X  sqr0 = 27; sqrt0 = 28;
X  string0 = 29; succ0 = 30;
X  true0 = 31; trunc0 = 32;
X  write0 = 33; writeln0 = 34;
X
X  { tokens }
X
X  mintoken = 0; maxtoken = 59;
X  and1 = 0; array1 = 1;
X  assume1 = 2; asterisk1 = 3;
X  bar1 = 4; becomes1 = 5;
X  begin1 = 6; case1 = 7;
X  charconst1 = 8; colon1 = 9;
X  comma1 = 10; const1 = 11;
X  div1 = 12; do1 = 13;
X  downto1 = 14; doubledot1 = 15;
X  else1 = 16; end1 = 17;
X  endtext1 = 18; equal1 = 19;
X  for1 = 20; forall1 = 21;
X  function1 = 22; greater1 = 23;
X  identifier1 = 24; if1 = 25;
X  intconst1 = 26;
X  leftbracket1 = 27;
X  leftparenthesis1 = 28;
X  less1 = 29; minus1 = 30;
X  mod1 = 31; newline1 = 32;
X  not1 = 33; notequal1 = 34;
X  notgreater1 = 35; notless1 = 36;
X  of1 = 37; or1 = 38;
X  parallel1 = 39; period1 = 40;
X  plus1 = 41; procedure1 = 42;
X  program1 = 43; realconst1 = 44;
X  record1 = 45; repeat1 = 46;
X  rightbracket1 = 47;
X  rightparenthesis1 = 48;
X  semicolon1 = 49; sic1 = 50;
X  slash1 = 51; stringconst1 = 52;
X  then1 = 53; to1 = 54;
X  type1 = 55; until1 = 56;
X  var1 = 57; while1 = 58;
X  unknown1 = 59;
X
X  { operation parts }
X
X  minoperation = 0;
X  maxoperation = 110;
X  abs2 = 0; absint2 = 1;
X  add2 = 2; addreal2 = 3;
X  and2 = 4; arctan2 = 5;
X  assign2 = 6; assume2 = 7;
X  case2 = 8; checkio2 = 9;
X  chr2 = 10; cos2 = 11;
X  divide2 = 12; divreal2 = 13;
X  do2 = 14; downto2 = 15;
X  endall2 = 16; enddown2 = 17;
X  endio2 = 18; endparallel2 = 19;
X  endproc2 = 20; endprocess2 = 21;
X  endprog2 = 22; endto2 = 23;
X  eof2 = 24; eoln2 = 25;
X  eqord2 = 26; eqreal2 = 27;
X  eqstring2 = 28; equal2 = 29;
X  exp2 = 30; field2 = 31;
X  float2 = 32; floatleft2 = 33;
X  for2 = 34; forall2 = 35;
X  goto2 = 36; grord2 = 37;
X  grreal2 = 38; grstring2 = 39;
X  index2 = 40; ln2 = 41;
X  lsord2 = 42; lsreal2 = 43;
X  lsstring2 = 44; minus2 = 45;
X  minusreal2 = 46; modulo2 = 47;
X  multiply2 = 48; multreal2 = 49;
X  neord2 = 50; nereal2 = 51;
X  nestring2 = 52; ngord2 = 53;
X  ngreal2 = 54; ngstring2 = 55;
X  nlord2 = 56; nlreal2 = 57;
X  nlstring2 = 58; not2 = 59;
X  notequal2 = 60; odd2 = 61;
X  open2 = 62; or2 = 63;
X  ordconst2 = 64; parallel2 = 65;
X  pred2 = 66; proccall2 = 67;
X  procedure2 = 68; process2 = 69;
X  program2 = 70; read2 = 71;
X  readint2 = 72; readln2 = 73;
X  readreal2 = 74; realconst2 = 75;
X  receive2 = 76; result2 = 77;
X  round2 = 78; send2 = 79;
X  sin2 = 80; sqr2 = 81;
X  sqrint2 = 82; sqrt2 = 83;
X  stringconst2 = 84;
X  subreal2 = 85; subtract2 = 86;
X  succ2 = 87; to2 = 88;
X  trunc2 = 89; value2 = 90;
X  variable2 = 91; varparam2 = 92;
X  write2 = 93; writebool2 = 94;
X  writeint2 = 95; writeln2 = 96;
X  writereal2 = 97;
X  writestring2 = 98;
X  globalcall2 = 99;
X  globalvalue2 = 100;
X  globalvar2 = 101;
X  localreal2 = 102;
X  localvalue2 = 103;
X  localvar2 = 104;
X  ordassign2 = 105;
X  ordvalue2 = 106;
X  realassign2 = 107;
X  realvalue2 = 108;
X  defaddr2 = 109; defarg2 = 110;
X
X  { compile-time errors }
X
X  ambiguous3 =
X    'ambiguous identifier          ';
X  block3 =
X    'function block error          ';
X  case3 =
X    'ambiguous case constant       ';
X  comment3 =
X    'incomplete comment            ';
X  forall3 =
X    'forall statement error        ';
X  kind3 =
X    'identifier kind error         ';
X  number3 =
X    'number error                  ';
X  parallel3 =
X    'parallel statement error      ';
X  parameter3 =
X    'function parameter error      ';
X  procedure3 =
X    'procedure statement error     ';
X  range3 =
X    'index range error             ';
X  recursion3 =
X    'recursion error               ';
X  syntax3 =
X    'syntax error                  ';
X  type3 =
X    'type error                    ';
X  undefined3 =
X    'undefined identifier          ';
X
X  { run-time errors }
X
X  assume4 =
X    'false assumption              ';
X  case4 =
X    'undefined case constant       ';
X  channel4 =
X    'undefined channel reference   ';
X  contention4 =
X    'channel contention            ';
X  deadlock4 =
X    'deadlock                      ';
X  range4 =
X    'range error                   ';
X  type4 =
X    'message type error            ';
X
X  { software failure }
X
X  maxaddr5 =
X    'memory limit exceeded         ';
X  maxblock5 =
X    'block limit exceeded          ';
X  maxbuf5 =
X    'buffer limit exceeded         ';
X  maxcase5 =
X    'case limit exceeded           ';
X  maxchan5 =
X    'channel limit exceeded        ';
X  maxchar5 =
X    'character limit exceeded      ';
X  maxlabel5 =
X    'branch limit exceeded         ';
X  maxlevel5 =
X    'nesting limit exceeded        ';
X  maxstring5 =
X    'string limit exceeded         ';
X
X  { miscellaneous phrases }
X
X  assembled =
X    'assembled                     ';
X  errorfile =
X    'errors                        ';
X  fileconflict =
X    'use different source and code ';
X  keyboard =
X    'keyboard                      ';
X  no =
X    'no                            ';
X  parsed =
X    'parsed                        ';
X  scanned =
X    'scanned                       ';
X  screen =
X    'screen                        ';
X  yes =
X    'yes                           ';
X
X  { characters and ordinal values }
X
X  apostrophe = '''' ; sp = ' ';
X  etx = 3; del = 127; nl = 10;
X  null = 0;
X
type
X  { common types }
X
X  binary = file of integer;
X  caserecord =
X    record
X      value, index: integer
X    end;
X  casetable =
X    array [1..maxcase] of caserecord;
X  phrase =
X    packed array [1..maxphrase] of
X      char;
X  string =
X    packed array [1..maxstring] of
X      char;
X  { a dual real is used with
X    an undefined tag field to
X    convert a real "a" to its
X    binary representation by
X    two integers "b" and "c"
X    (or vice versa) }
X  dualreal =
X    record
X      case split: boolean of
X        false: (a: real);
X        true: (b, c: integer)
X    end;
X
{ phrase routines }
X
function phraselength(
X  value: phrase): integer;
var i, j: integer;
begin
X  i := 0; j := maxphrase;
X  while i < j do
X    if value[j] = sp
X      then j := j - 1
X      else i := j;
X  phraselength := i
end;
X
procedure writephrase(
X  var outfile: text;
X  value: phrase);
begin
X  write(outfile, value:
X    phraselength(value))
end;
X
procedure readphrase(
X  var value: phrase);
var ch: char; i: integer;
begin
X  repeat
X    while eoln do readln;
X    read(ch)
X  until ch <> sp;
X  value[1] := ch;
X  for i := 2 to maxphrase do
X    if not eoln
X      then read(value[i])
X      else value[i] := sp;
X  while not eoln do read(ch);
X  readln
end;
X
procedure readboolean(
X  var value: boolean);
var word: phrase;
begin
X  readphrase(word);
X  while (word <> yes)
X    and (word <> no) do
X      begin
X        write(
X          '      yes or no? ');
X        readphrase(word)
X      end;
X  value := (word = yes)
end;
X
{ string routines }
X
function stringlength(
X  value: string): integer;
var i, j: integer;
begin
X  i := 0; j := maxstring;
X  while i < j do
X    if value[j] = chr(null)
X      then j := j - 1
X      else i := j;
X  stringlength := i
end;
X
procedure writestring(
X  var outfile: text;
X  value: string;
X  width: integer);
var i, n: integer;
begin
X  n := stringlength(value);
X  if width > n then
X    for i := 1 to width - n do
X      write(outfile, sp)
X  else n := width;
X  write(outfile, value:n)
end;
SHAR_EOF
  $shar_touch -am 1029021698 'common.p' &&
  chmod 0600 'common.p' ||
  $echo 'restore of' 'common.p' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'common.p:' 'MD5 check failed'
9e68fbb462f94c55c05652bd5ee16cd8  common.p
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'common.p'`"
    test 7919 -eq "$shar_count" ||
    $echo 'common.p:' 'original size' '7919,' 'current size' "$shar_count!"
  fi
fi
# ============= scan.p ==============
if test -f 'scan.p' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'scan.p' '(file already exists)'
else
  $echo 'x -' extracting 'scan.p' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'scan.p' &&
{         SUPERPASCAL COMPILER
X                SCANNER
X            28 October 1993
X  Copyright (c) 1993 Per Brinch Hansen }
X
procedure scan(var lineno: integer;
X  procedure accept(var value: char);
X  procedure put(value: integer);
X  procedure putreal(value: real);
X  procedure putstring(
X    length: integer;
X    value: string);
X  procedure error(kind: phrase);
X  procedure halt(kind: phrase));
const
X  maxkey = 631; maxshort = 10;
type
X  charset = set of char;
X  short =
X    packed array [1..maxshort] of
X      char;
X  spellingtable =
X    array [1..maxchar] of char;
X  wordpointer = ^ wordrecord;
X  wordrecord =
X    record
X      nextword: wordpointer;
X      symbol: boolean;
X      index, length, lastchar:
X        integer
X    end;
X  hashtable =
X    array [1..maxkey] of wordpointer;
var
X  ch: char; afterperiod: boolean;
X  alphanumeric, capitalletters,
X  digits, endcomment, endline,
X  invisible, letters, radix,
X  separators, smallletters: charset;
X  spelling: spellingtable;
X  characters, identifiers: integer;
X  hash: hashtable;
X  nulstring: string;
X
{ INPUT }
X
procedure nextchar;
var skipped: boolean;
begin
X  repeat
X    accept(ch);
X    if (ch < chr(null))
X      or (ch > chr(del))
X    then
X      skipped := true
X    else
X      skipped := ch in invisible
X  until not skipped
end;
X
{ OUTPUT }
X
procedure emit1(sym: integer);
begin put(sym) end;
X
procedure emit2(
X  sym, arg: integer);
begin
X  put(sym); put(arg)
end;
X
procedure emitreal(value: real);
begin
X  put(realconst1);
X  putreal(value)
end;
X
procedure emitstring(
X  length: integer;
X  value: string);
begin
X  put(stringconst1);
X  putstring(length, value)
end;
X
{ WORD SYMBOLS AND IDENTIFIERS }
X
function key(text: string;
X  length: integer): integer;
const w = 32641 { 32768 - 127 };
X  n = maxkey;
var i, sum: integer;
begin
X  sum := 0; i := 1;
X  while i <= length do
X    begin
X      sum := (sum + ord(text[i]))
X        mod w;
X      i := i + 1
X    end;
X  key := sum mod n + 1
end;
X
procedure insert(
X  symbol: boolean; text: string;
X  length, index, keyno: integer);
var pointer: wordpointer;
X  m, n: integer;
begin
X  { insert word in
X    spelling table }
X  characters :=
X    characters + length;
X  if characters > maxchar then
X    halt(maxchar5);
X  m := length;
X  n := characters - m;
X  while m > 0 do
X    begin
X      spelling[m + n] := text[m];
X      m := m - 1
X    end;
X  { insert word in a word list }
X  new(pointer);  
X  pointer^.nextword :=
X    hash[keyno];
X  pointer^.symbol := symbol;
X  pointer^.index := index;
X  pointer^.length := length;
X  pointer^.lastchar :=
X    characters;
X  hash[keyno] := pointer
end;
X
function found(text: string;
X  length: integer;
X  pointer: wordpointer): boolean;
var same: boolean; m, n: integer;
begin
X  if pointer^.length = length then
X    begin
X      same := true; m := length;
X      n := pointer^.lastchar - m;
X      while same and (m > 0) do
X        begin
X          same := text[m] =
X            spelling[m + n];
X          m := m - 1
X        end
X    end
X  else same := false;
X  found := same
end;
X
procedure declare(
X  shorttext: short;
X  index: integer;
X  symbol: boolean);
var i, length: integer;
X  text: string;
begin
X  length := maxshort;
X  while shorttext[length] = sp
X    do length := length - 1;
X  for i := 1 to length do
X    text[i] := shorttext[i];
X  insert(symbol, text, length,
X    index, key(text, length))
end;
X
procedure search(
X  text: string;
X  length: integer;
X  var symbol: boolean;
X  var index: integer);
var keyno: integer;
X  pointer: wordpointer;
X  done: boolean;
begin
X  keyno := key(text, length);
X  pointer := hash[keyno];
X  done := false;
X  while not done do
X    if pointer = nil then
X      begin
X        symbol := false;
X        identifiers :=
X          identifiers + 1;
X        index := identifiers;
X        insert(false, text,
X          length, index, keyno);
X        done := true
X      end
X    else if
X      found(text, length, pointer)
X        then
X      begin
X        symbol := pointer^.symbol;
X        index := pointer^.index;
X        done := true
X      end
X    else
X      pointer := pointer^.nextword
end;
X
{ WordSymbol =
X    "and" | "array" | "assume" |
X    "begin" | "case" | "const" |
X    "div" | "do" | "downto" |
X    "else" | "end" | "for" |
X    "forall" | "function" | "if" |
X    "mod" | "not" | "of" | "or" |
X    "parallel" | "procedure" |
X    "program" | "record" |
X    "repeat" | "sic" | "then" |
X    "to" | "type" | "until" |
X    "var" | "while" .
X  UnusedWord =
X    "file" | "goto" | "in" |
X    "label" | "nil" | "packed" |
X    "set" | "with" . }
X
procedure initialize;
var i: integer;
begin
X  digits := ['0'..'9'];
X  capitalletters := ['A'..'Z'];
X  smallletters := ['a'..'z'];
X  letters :=
X    capitalletters + smallletters;
X  alphanumeric := letters + digits;
X  endcomment := ['}', chr(etx)];
X  endline := [chr(nl), chr(etx)];
X  invisible :=
X    [chr(0)..chr(31), chr(127)]
X      - [chr(nl), chr(etx)];
X  radix := ['e', 'E'];
X  separators := [sp, chr(nl), '{'];
X  for i := 1 to maxkey do
X    hash[i] := nil;
X  for i := 1 to maxstring do
X    nulstring[i] := chr(null);
X  characters := 0;
X  { insert word symbols }
X  declare('and       ', and1,
X    true);
X  declare('array     ', array1,
X    true);
X  declare('assume    ', assume1,
X    true);
X  declare('begin     ', begin1,
X    true);
X  declare('case      ', case1,
X    true);
X  declare('const     ', const1,
X    true);
X  declare('div       ', div1,
X    true);
X  declare('do        ', do1,
X    true);
X  declare('downto    ', downto1,
X    true);
X  declare('else      ', else1,
X    true);
X  declare('end       ', end1,
X    true);
X  declare('file      ', unknown1,
X    true);
X  declare('for       ', for1,
X    true);
X  declare('forall    ', forall1,
X    true);
X  declare('function  ', function1,
X    true);
X  declare('goto      ', unknown1,
X    true);
X  declare('if        ', if1,
X    true);
X  declare('in        ', unknown1,
X    true);
X  declare('label     ', unknown1,
X    true);
X  declare('mod       ', mod1,
X    true);
X  declare('nil       ', unknown1,
X    true);
X  declare('not       ', not1,
X    true);
X  declare('of        ', of1,
X    true);
X  declare('or        ', or1,
X    true);
X  declare('packed    ', unknown1,
X    true);
X  declare('parallel  ', parallel1,
X    true);
X  declare('procedure ', procedure1,
X    true);
X  declare('program   ', program1,
X    true);
X  declare('record    ', record1,
X    true);
X  declare('repeat    ', repeat1,
X    true);
X  declare('set       ', unknown1,
X    true);
X  declare('sic       ', sic1,
X    true);
X  declare('then      ', then1,
X    true);
X  declare('to        ', to1,
X    true);
X  declare('type      ', type1,
X    true);
X  declare('until     ', until1,
X    true);
X  declare('var       ', var1,
X    true);
X  declare('while     ', while1,
X    true);
X  declare('with      ', unknown1,
X    true);
X  { insert standard identifiers }
X  declare('abs       ', abs0,
X    false);
X  declare('arctan    ', arctan0,
X    false);
X  declare('boolean   ', boolean0,
X    false);
X  declare('char      ', char0,
X    false);
X  declare('chr       ', chr0,
X    false);
X  declare('cos       ', cos0,
X    false);
X  declare('eof       ', eof0,
X    false);
X  declare('eoln      ', eoln0,
X    false);
X  declare('exp       ', exp0,
X    false);
X  declare('false     ', false0,
X    false);
X  declare('integer   ', integer0,
X    false);
X  declare('ln        ', ln0,
X    false);
X  declare('maxint    ', maxint0,
X    false);
X  declare('maxstring ', maxstring0,
X    false);
X  declare('null      ', null0,
X    false);
X  declare('odd       ', odd0,
X    false);
X  declare('open      ', open0,
X    false);
X  declare('ord       ', ord0,
X    false);
X  declare('pred      ', pred0,
X    false);
X  declare('read      ', read0,
X    false);
X  declare('readln    ', readln0,
X    false);
X  declare('real      ', real0,
X    false);
X  declare('receive   ', receive0,
X    false);
X  declare('round     ', round0,
X    false);
X  declare('send      ', send0,
X    false);
X  declare('sin       ', sin0,
X    false);
X  declare('sqr       ', sqr0,
X    false);
X  declare('sqrt      ', sqrt0,
X    false);
X  declare('string    ', string0,
X    false);
X  declare('succ      ', succ0,
X    false);
X  declare('true      ', true0,
X    false);
X  declare('trunc     ', trunc0,
X    false);
X  declare('write     ', write0,
X    false);
X  declare('writeln   ', writeln0,
X    false);
X  identifiers := maxstandard;
X  afterperiod := false
end;
X
{ LEXICAL ANALYSIS }
X
{ Comment =
X    LeftBrace [ CommentElement ]*
X      RightBrace .
X  CommentElement =
X    GraphicCharacter | NewLine |
X    Comment . }
X
procedure comment;
begin
X  (* ch = '{' *) nextchar;
X  while not (ch in endcomment) do
X    if ch = '{' then comment
X    else
X      begin
X        if ch = chr(nl) then
X          begin
X            nextchar;
X            emit2(newline1, lineno)
X          end
X        else nextchar
X      end;
X  if ch = '}' then nextchar
X  else error(comment3)
end;
X
{ Word =
X    WordSymbol | Identifier .
X  Identifier =
X    Letter [ Letter | Digit ]* . }
X
procedure word;
var symbol: boolean; text: string;
X  length, index: integer;
begin
X  { ch in letters }
X  length := 0;
X  while ch in alphanumeric do
X    begin
X      { convert a capital letter
X        (if any) to lower case }
X      if ch in capitalletters then
X        ch := chr(ord(ch) +
X          ord('a') - ord('A'));
X      if length = maxstring then
X        halt(maxstring5);
X      length := length + 1;
X      text[length] := ch;
X      nextchar;
X    end;
X  search(text, length, symbol,
X    index);
X  if symbol then emit1(index)
X  else emit2(identifier1, index)
end;
X
function scaled(r: real;
X  s: integer): real;
{ scaled(r,s) = r*(10**s) }
var max, min: real;
begin
X  max := maxreal / 10.0;
X  while s > 0 do
X    begin
X      if r <= max then
X        r := r * 10.0
X      else error(number3);
X      s := s - 1
X    end;
X  min := 10.0 * minreal;
X  while s < 0 do
X    begin
X      if r >= min then
X        r := r / 10.0
X      else r := 0.0;
X      s := s + 1
X    end;
X  scaled := r
end;
X
{ DigitSequence =
X    Digit [ Digit ]* . }
X
procedure digitsequence(
X  var r: real;
X  var n: integer);
{ r := digitsequence;
X  n := length(r) }
var d: real;
begin
X  r := 0.0; n := 0;
X  if ch in digits then
X    while ch in digits do
X      begin
X        d := ord(ch) - ord('0');
X        r := 10.0 * r + d;
X        n := n + 1;
X        nextchar
X      end
X  else error(number3)
end;
X
{ UnsignedScaleFactor =
X    DigitSequence . }
X
procedure unsignedscalefactor(
X  var s: integer);
{ s := scalefactor }
var r: real; n: integer;
begin
X  digitsequence(r, n);
X  if r > maxint then
X    begin
X      error(number3);
X      s := 0
X    end
X  else s := trunc(r)
end;
X
{ ScaleFactor =
X    [ Sign ]
X      UnsignedScaleFactor .
X  Sign =
X    "+" | "-" . }
X
procedure scalefactor(
X  var s: integer);
{ s := scalefactor }
begin
X  if ch = '+' then
X    begin
X      nextchar;
X      unsignedscalefactor(s)
X    end
X  else if ch = '-' then
X    begin
X      nextchar;
X      unsignedscalefactor(s);
X      s := - s
X    end
X  else unsignedscalefactor(s)
end;
X
{ UnsignedInteger =
X    DigitSequence . }
X
procedure unsignedinteger(
X  r: real);
var i: integer;
begin
X  if r >  maxint then
X    begin
X      error(number3);
X      i := 0
X    end
X  else i := trunc(r);
X  emit2(intconst1, i)
end;
X
{ UnsignedNumber =
X    UnsignedReal |
X    UnsignedInteger .
X  UnsignedReal =
X    IntegerPart RealOption .
X  IntegerPart =
X    DigitSequence .
X  RealOption =
X    "." FractionalPart
X      [ ScalingPart ] |
X    ScalingPart .
X  FractionalPart =
X    DigitSequence .
X  ScalingPart =
X    Radix ScaleFactor .
X  Radix =
X    "e" | "E" . }
X
procedure unsignednumber;
var i, f, r: real;
X  s, n: integer;
begin
X  digitsequence(i, n);
X  if ch = '.' then
X    begin
X      nextchar;
X      if ch = '.' then
X        begin
X          { input = i..
X            and ch = '.' }
X          unsignedinteger(i);
X          afterperiod := true
X        end
X      else
X        begin
X          digitsequence(f, n);
X          r := i + scaled(f, -n);
X          { r = i.f }
X          if ch in radix then
X            begin
X              nextchar;
X              scalefactor(s);
X              r := scaled(r, s)
X              {r = i.f*(10**s) }
X            end;
X          emitreal(r)
X        end
X    end
X  else if ch in radix then
X    begin
X      nextchar;
X      scalefactor(s);
X      r := scaled(i, s);
X      { r = i*(10**s) }
X      emitreal(r)
X    end
X  else unsignedinteger(i)
end;
X
{ StringElement =
X    StringCharacter |
X    ApostropheImage .
X  ApostropheImage =
X    "''" . }
X
procedure stringelement(
X  var text: string;
X  var length: integer);
begin
X  if length = maxstring then
X    halt(maxstring5);
X  length := length + 1;
X  text[length] := ch;
X  nextchar
end;
X
{ CharacterString =
X    "'" StringElements "'" .
X  StringElements =
X    StringElement
X      [ StringElement ]* . }
X
procedure characterstring;
type state =
X  (extend, accept, reject);
var length: integer; s: state;
X  text: string;
begin
X  { ch = apostrophe }
X  text := nulstring;
X  length := 0;
X  nextchar; s := extend;
X  while s = extend do
X    if ch in endline then
X      s := reject
X    else if ch = apostrophe then
X      begin
X        nextchar;
X        if ch = apostrophe then
X          stringelement(text,
X            length)
X        else s := accept
X      end
X    else
X      stringelement(text, length);
X  if (s = accept) and (length > 0)
X    then
X      if length = 1 then
X        emit2(charconst1,
X          ord(text[1]))
X      else
X        emitstring(length, text)
X    else emit1(unknown1)
end;
X
{ TokenField =
X    [ Separator ]* Token .
X  Token =
X    Literal | Identifier |
X    SpecialSymbol | UnknownToken |
X    EndText .
X  Literal =
X    UnsignedNumber |
X    CharacterString .
X  SpecialSymbol =
X    "(" | ")" | "*" | "+" | "," |
X    "-" | "." | "/" | ":" | ";" |
X    "<" | "=" | ">" | "[" | "]" |
X    ".." | ":=" | "<=" | "<>" |
X    ">=" | "|" | WordSymbol .
X  UnknownToken =
X    UnusedWord | UnusedCharacter .
X  UnusedCharacter =
X    "!" | """ | "#" | "$" | "%" |
X    "&" | "?" | "@" | "\" | "^" |
X    "_" | "`" | "~" . }
X
procedure nexttoken;
begin
X  while ch in separators do
X    if ch = sp then nextchar
X    else if ch = chr(nl) then
X      begin
X        nextchar;
X        emit2(newline1, lineno)
X      end
X    else (* ch = '{' *) comment;
X  if ch in letters then word
X  else if ch in digits then
X    unsignednumber
X  else if ch = apostrophe then
X    characterstring
X  else if ch = '+' then
X    begin
X      emit1(plus1);
X      nextchar
X    end
X  else if ch = '-' then
X    begin
X      emit1(minus1);
X      nextchar
X    end
X  else if ch = '*' then
X    begin
X      emit1(asterisk1);
X      nextchar;
X    end
X  else if ch = '/' then
X    begin
X      emit1(slash1);
X      nextchar
X    end
X  else if ch = '<' then
X    begin
X      nextchar;
X      if ch = '=' then
X        begin
X          emit1(notgreater1);
X          nextchar
X        end
X      else if ch = '>' then
X        begin
X          emit1(notequal1);
X          nextchar
X        end
X      else emit1(less1)
X    end
X  else if ch = '=' then
X    begin
X      emit1(equal1);
X      nextchar
X    end
X  else if ch = '>' then
X    begin
X      nextchar;
X      if ch = '=' then
X        begin
X          emit1(notless1);
X          nextchar
X        end
X      else emit1(greater1)
X    end
X  else if ch = ':' then
X    begin
X      nextchar;
X      if ch = '=' then
X        begin
X          emit1(becomes1);
X          nextchar
X        end
X      else emit1(colon1)
X    end
X  else if ch = '(' then
X    begin
X      emit1(leftparenthesis1);
X      nextchar
X     end
X  else if ch = ')' then
X    begin
X      emit1(rightparenthesis1);
X      nextchar
X    end
X  else if ch = '[' then
X    begin
X      emit1(leftbracket1);
X      nextchar
X    end
X  else if ch = ']' then
X    begin
X      emit1(rightbracket1);
X      nextchar
X    end
X  else if ch = ',' then
X    begin
X      emit1(comma1);
X      nextchar
X    end
X  else if ch = '.' then
X    if afterperiod then
X      begin
X        emit1(doubledot1);
X        nextchar;
X        afterperiod := false
X      end
X    else
X      begin
X        nextchar;
X        if ch = '.' then
X          begin
X            emit1(doubledot1);
X            nextchar
X          end
X        else emit1(period1)
X      end
X  else if ch = ';' then
X    begin
X      emit1(semicolon1);
X      nextchar
X    end
X  else if ch = '|' then
X    begin
X      emit1(bar1);
X      nextchar
X    end
X  else if ch <> chr(etx) then
X    begin
X      emit1(unknown1);
X      nextchar
X    end
end;
X
{ Program =
X    TokenField [ TokenField ]* . }
X
begin
X  initialize; nextchar;
X  emit2(newline1, lineno);
X  while ch <> chr(etx) do
X    nexttoken;
X  emit1(endtext1)
end;
SHAR_EOF
  $shar_touch -am 1029021698 'scan.p' &&
  chmod 0600 'scan.p' ||
  $echo 'restore of' 'scan.p' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'scan.p:' 'MD5 check failed'
8de0430fff9b7ebe412e103ccc76fa3b  scan.p
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'scan.p'`"
    test 16455 -eq "$shar_count" ||
    $echo 'scan.p:' 'original size' '16455,' 'current size' "$shar_count!"
  fi
fi
# ============= parse.p ==============
if test -f 'parse.p' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'parse.p' '(file already exists)'
else
  $echo 'x -' extracting 'parse.p' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'parse.p' &&
{         SUPERPASCAL COMPILER
X                 PARSER
X             28 October 1993
X  Copyright (c) 1993 Per Brinch Hansen }
X
procedure parse(
X  procedure newline(lineno: integer);
X  procedure get(var value: integer);
X  procedure put(value: integer);
X  procedure getreal(var value: real);
X  procedure putreal(value: real);
X  procedure getstring(
X    var length: integer;
X    var value: string);
X  procedure putstring(
X    length: integer;
X    value: string);
X  procedure putcase(
X    lineno, length: integer;
X    table: casetable);
X  procedure error(kind: phrase);
X  procedure halt(kind: phrase));
const
X  nameless = 0;
type
X  tokens = set of mintoken..maxtoken;
X  messagepointer = ^ messagerecord;
X  pointer = ^ objectrecord;
X  stringpointer = ^ string;
X  varset = ^ atom;
X  class =
X    (arraytype, channeltype, field,
X    funktion, ordconst, ordtype,
X    procedur, realconst, realtype,
X    recordtype, standardfile,
X    standardfunc, standardproc,
X    stringconst, valueparameter,
X    variable, varparameter,
X    undefined);
X  classes = set of class;
X  atom =
X    record
X      next: varset;
X      item: pointer
X    end;
X  context =
X    record
X      exprvar, targetvar: varset
X    end;
X  messagerecord =
X    record
X      previous: messagepointer;
X      typex: pointer;
X    end;
X  objectrecord =
X    record
X      id: integer;
X      previous: pointer;
X      case kind: class of
X        ordconst:
X          (ordvalue: integer;
X           ordtypex: pointer);
X        realconst:
X          (realvalue: real);
X        stringconst:
X          (stringptr: stringpointer);
X        ordtype:
X          (minvalue, maxvalue:
X           integer);
X        realtype:
X          ( );
X        arraytype:
X          (lowerbound, upperbound,
X           arraylength: integer; 
X           indextype, elementtype:
X           pointer);
X        recordtype:
X          (recordlength: integer;
X           lastfield: pointer);
X        channeltype:
X          (messagelist:
X             messagepointer);
X        field:
X          (fielddispl: integer;
X           fieldtype: pointer);
X        valueparameter, variable,
X          varparameter:
X          (varlevel, vardispl:
X           integer; vartype:
X           pointer);
X        funktion, procedur:
X          (proclevel, proclabel,
X           paramlength, varlength:
X           integer; lastparam,
X           resulttype: pointer;
X           recursive: boolean;
X           implicit: context);
X        standardfile, standardfunc,
X          standardproc, undefined:
X          ( )
X    end;
X  blockrecord =
X    record
X      templength, maxtemp: integer;
X      heading, lastobject: pointer
X    end;
X  blocktable = array [0..maxlevel] of
X    blockrecord;
var
X  lineno, token, argument: integer;
X  realarg: real; stringarg: string;
X  addtokens, blocktokens,
X  constanttokens, declarationtokens,
X  doubletokens, expressiontokens,
X  factortokens, literaltokens,
X  longtokens, multiplytokens,
X  parametertokens, relationtokens,  
X  routinetokens, selectortokens,
X  signtokens, simpleexprtokens,
X  statementtokens, termtokens,
X  unsignedtokens: tokens;
X  block: blocktable;
X  blocklevel: integer;
X  constants, functions, leftparts,
X  types, variables, parameters,
X  procedures: classes;
X  inputfile, outputfile,
X  typeboolean, typechar,
X  typeinteger, typereal,
X  typestring, typeuniversal:
X  pointer;
X  labelno, minint: integer;
X
{ FORWARD DECLARATIONS }
X
procedure push(length: integer);
forward;
X
procedure pop(length: integer);
forward;
X
procedure expression(
X  var typex: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
forward;
X
procedure statementsequence(
X  var used: context;  
X  restricted: boolean;
X  stop: tokens);
forward;
X
procedure statement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
forward;
X
procedure declarationpart(
X  var varlength: integer;
X  stop: tokens);
forward;
X
procedure statementpart(
X  var templength: integer;
X  var used: context;
X  stop: tokens);
forward;
X
{ INPUT }
X
procedure nexttoken;
begin
X  get(token);
X  while token = newline1 do
X    begin
X      get(lineno); newline(lineno);
X      get(token)
X    end;
X  if token in longtokens then
X    if token in doubletokens then
X      get(argument)
X    else if token = realconst1 then
X      getreal(realarg)
X    else { token = stringconst1 }
X      getstring(
X        argument {(redundant)},
X        stringarg)
end;
X
{ OUTPUT }
X
procedure emit1(op: integer);
begin put(op) end;
X
procedure emit2(
X  op, arg: integer); 
begin put(op); put(arg) end;
X
procedure emit3(
X  op, arg1, arg2: integer);
begin
X  put(op); put(arg1);
X  put(arg2)
end;
X
procedure emit4(
X  op, arg1, arg2,
X  arg3: integer);
begin
X  put(op); put(arg1);
X  put(arg2); put(arg3)
end;
X
procedure emit5(
X  op, arg1, arg2, arg3,
X  arg4: integer);
begin
X  put(op); put(arg1);
X  put(arg2); put(arg3);
X  put(arg4)
end;
X
procedure emit6(
X  op, arg1, arg2, arg3,
X  arg4, arg5: integer);
begin
X  put(op); put(arg1);
X  put(arg2); put(arg3);
X  put(arg4); put(arg5)
end;
X
procedure emitreal(
X  value: real);
begin
X  put(realconst2);
X  putreal(value)
end;
X
procedure emitstring(
X  value: string);
begin
X  put(stringconst2);
X  putstring(
X    stringlength(value),
X    value);
end;
X
procedure emitcase(
X  lineno, length: integer;
X  table: casetable);
begin
X  put(case2);
X  putcase(lineno, length,
X    table);
end;
X
{ VARIABLE SETS }
X
function empty(x: varset)
X  : boolean;
{ empty = (x = []) }
begin
X  empty := x = nil
end;
X
function member(x: varset;
X  y: pointer): boolean;
{ member = y in x }
var correct: boolean;
begin
X  correct := false;
X  while not correct
X    and (x <> nil) do
X      if x^.item = y then
X        correct := true
X      else x := x^.next;
X  member := correct
end;
X
function disjoint(
X  x, y: varset): boolean;
{ disjoint = empty(x*y) }
var correct: boolean;
begin
X  correct := true;
X  while correct and
X    (x <> nil) do
X      if member(y, x^.item)
X        then correct := false
X        else x := x^.next;
X  disjoint := correct
end;
X
procedure newset(
X  var x: varset);
{ x := [] }
begin x := nil end;
X
procedure include(
X  var x: varset;
X  y: pointer);
{ x := x + [y] }
var v: varset;
begin
X  if not member(x, y) then
X    begin
X      new(v);
X      v^.next := x;
X      v^.item := y;
X      x := v
X    end
end;
X
procedure addset(
X  var x: varset;
X  y: varset);
{ x := x + y }
begin
X  while y <> nil do
X    begin
X      include(x, y^.item);
X      y := y^.next
X    end
end;
X
procedure copyset(
X  var x: varset;
X  y: varset);
{ x := y }
begin
X  newset(x);
X  addset(x, y)
end;
X
{ GLOBAL VARIABLES }
X
function globalvar(
X  proc, object: pointer)
X    : boolean;
{ globalvar = the object
X  is a variable that is
X  global to a procedure
X  (or function) }
var kind: class;
begin
X  kind := object^.kind;
X  if kind in variables then
X    globalvar :=
X      object^.varlevel <=
X        proc^.proclevel
X  else if kind = standardfile
X    then globalvar := true
X  else globalvar := false
end;
X
procedure globalset(
X  proc: pointer;
X  var left: varset;
X  right: varset);
{ left := all members of
X  right which are global
X  to a procedure (or
X  function) }
var item: pointer;
begin
X  newset(left);
X  while right <> nil do
X    begin
X      item := right^.item;
X      if globalvar(proc, item)
X        then
X          include(left, item);
X      right := right ^.next
X    end
end;
X
{ STATEMENT CONTEXTS }
X
function emptycontext(
X  used: context): boolean;
{ emptycontext =
X    (used = []) }
begin
X  emptycontext :=
X    empty(used.exprvar) and
X    empty(used.targetvar)
end;
X
procedure newcontext(
X  var used: context);
{ used := [] }
begin
X  newset(used.targetvar);
X  newset(used.exprvar)
end;
X
procedure addcontext(
X  var left: context;
X  right: context);
{ left := left + right }
begin
X  addset(left.targetvar,
X    right.targetvar);
X  addset(left.exprvar,
X    right.exprvar)
end;
X
procedure copycontext(
X  var left: context;
X  right: context);
{ left := right }
begin
X  newcontext(left);
X  addcontext(left, right)
end;
X
procedure globalcontext(
X  proc: pointer;
X  var left: context;
X  right: context);
{ left := all members of
X  right which are global
X  to a procedure or
X  function }
begin
X  globalset(proc,
X    left.targetvar,
X    right.targetvar);
X  globalset(proc,
X    left.exprvar,
X    right.exprvar)
end;
X
{ SCOPE ANALYSIS }
X
procedure search(
X  id, levelno: integer;
X  var found: boolean;
X  var object: pointer);
var more: boolean;
begin
X  more := true;
X  object :=
X    block[levelno].lastobject;
X  while more do
X    if object = nil then
X      begin
X        more := false;
X        found := false
X      end
X    else if object^.id = id then
X      begin
X        more := false;
X        found := true
X      end
X    else
X      object := object^.previous
end;
X
procedure declare(
X  id: integer; kind: class;
X  var object: pointer);
var found: boolean;
X  other: pointer;
begin
X  if id <> nameless then
X    begin
X      search(id, blocklevel,
X        found, other);
X      if found then
X        error(ambiguous3)
X    end;
X  new(object);
X  object^.id := id;
X  object^.previous :=
X    block[blocklevel].lastobject;
X  object^.kind := kind;
X  block[blocklevel].lastobject :=
X    object
end;
X
procedure find(id: integer;
X  var object: pointer);
var more, found: boolean;
X  levelno: integer;
begin
X  more := true;
X  levelno := blocklevel;
X  while more do
X    begin
X      search(id, levelno, found,
X        object);
X      if found or
X        (levelno = 0) then
X          more := false
X      else levelno := levelno - 1
X    end;
X  if not found then
X    begin
X      error(undefined3);
X      declare(id, undefined, object)
X    end
end;
X
function within(proc: pointer)
X  : boolean;
var levelno: integer;
X  more: boolean;
begin
X  more := true;
X  levelno := blocklevel;
X  while more do
X    if block[blocklevel].heading
X        = proc then
X      begin
X        more := false;
X        within := true
X      end
X    else if levelno = 0 then
X      begin
X        more := false;
X        within := false
X      end
X    else levelno := levelno - 1
end;
X
procedure checkblock;
var proc: pointer;
begin
X  proc :=
X    block[blocklevel].heading;
X  if proc <> nil then
X    if proc^.kind = funktion then
X       error(block3)
end;
X    
X
procedure newblock(
X  heading: pointer);
var current: blockrecord;
begin
X  if blocklevel = maxlevel then
X    halt(maxlevel5);
X  blocklevel := blocklevel + 1;
X  current.templength := 0;
X  current.maxtemp := 0;
X  current.heading := heading;
X  current.lastobject := nil;
X  block[blocklevel] := current
end;
X
procedure endblock;
begin
X  blocklevel := blocklevel - 1
end;
X
procedure standardblock;
var p: pointer;
begin
X  blocklevel := -1;
X  newblock(nil);
X  { standard files }
X  declare(nameless, standardfile,
X    inputfile);
X  declare(nameless, standardfile,
X    outputfile);
X  { standard types }
X  declare(boolean0, ordtype, p);
X  typeboolean := p;
X  p^.minvalue := ord(false);
X  p^.maxvalue := ord(true);
X  declare(char0, ordtype, p);
X  typechar := p;
X  p^.minvalue := ord(chr(null));
X  p^.maxvalue := ord(chr(del));
X  declare(integer0, ordtype, p);
X  typeinteger := p;
X  p^.minvalue := minint;
X  p^.maxvalue := maxint;
X  declare(real0, realtype, p);
X  typereal := p;
X  declare(string0, arraytype, p);
X  typestring := p;
X  p^.lowerbound := 1;
X  p^.upperbound := maxstring;
X  p^.arraylength := maxstring;
X  p^.indextype := typeinteger;
X  p^.elementtype := typechar;
X  declare(nameless, ordtype, p);
X  typeuniversal := p;
X  p^.minvalue := 0;
X  p^.maxvalue := 0;
X  { standard constants }
X  declare(false0, ordconst, p);
X  p^.ordvalue := ord(false);
X  p^.ordtypex := typeboolean;
X  declare(maxint0, ordconst, p);
X  p^.ordvalue := maxint;
X  p^.ordtypex := typeinteger;
X  declare(maxstring0, ordconst, p);
X  p^.ordvalue := maxstring;
X  p^.ordtypex := typeinteger;
X  declare(null0, ordconst, p);
X  p^.ordvalue := ord(chr(null));
X  p^.ordtypex := typechar;
X  declare(true0, ordconst, p);
X  p^.ordvalue := ord(true);
X  p^.ordtypex := typeboolean;
X  { standard procedures }
X  declare(open0, standardproc, p);
X  declare(read0, standardproc, p);
X  declare(readln0, standardproc, p);
X  declare(receive0, standardproc, p);
X  declare(send0, standardproc, p);
X  declare(write0, standardproc, p);
X  declare(writeln0, standardproc, p);
X  { standard functions }
X  declare(abs0, standardfunc, p);
X  declare(arctan0, standardfunc, p);
X  declare(chr0, standardfunc, p);
X  declare(cos0, standardfunc, p);
X  declare(eof0, standardfunc, p);
X  declare(eoln0, standardfunc, p);
X  declare(exp0, standardfunc, p);
X  declare(ln0, standardfunc, p);
X  declare(odd0, standardfunc, p);
X  declare(ord0, standardfunc, p);
X  declare(pred0, standardfunc, p);
X  declare(round0, standardfunc, p);
X  declare(sin0, standardfunc, p);
X  declare(sqr0, standardfunc, p);
X  declare(sqrt0, standardfunc, p);
X  declare(succ0, standardfunc, p);
X  declare(trunc0, standardfunc, p)
end;
X
{ TYPE ANALYSIS }
X
procedure checktypes(
X  var type1: pointer;
X  type2: pointer);
begin
X  if type1 <> type2 then
X    begin
X      if (type1 <> typeuniversal)
X        and
X          (type2 <> typeuniversal)
X            then error(type3);
X      type1 := typeuniversal
X    end
end;
X
procedure typeerror(
X  var typex: pointer);
begin
X  if typex <> typeuniversal then
X    begin
X      error(type3);
X      typex := typeuniversal
X    end
end;
X
procedure checktype(
X  var typex: pointer;
X  kind: class);
begin
X  if typex^.kind <> kind then
X    typeerror(typex)
end;
X
procedure checkmessage(
X  var type1, type2: pointer;
X  var typeno: integer);
{ typeno > 0 }
var mess: messagepointer;
X  found: boolean;
begin
X  typeno := 1;
X  if type1^.kind = channeltype then
X    begin
X      mess := type1^.messagelist;
X      found := false;
X      while not found and
X          (mess <> nil) do
X        if mess^.typex <> type2 then
X          begin
X            typeno := typeno + 1;
X            mess := mess^.previous
X          end
X        else found := true;
X      if not found then
X        typeerror(type2)
X    end
X  else typeerror(type1)
end;
X
procedure kinderror(
X  object: pointer);
begin
X  if object^.kind <> undefined
X    then error(kind3)
end;
X
procedure convert1(
X  var type1: pointer;
X  type2: pointer);
begin
X  if (type1 = typeinteger) and
X    (type2 = typereal) then
X      begin
X        emit1(float2);
X        pop(1); push(2);
X        type1 := typereal
X      end
end;
X
procedure convert2(
X  var type1, type2: pointer);
begin
X  if (type1 = typeinteger) and
X    (type2 = typereal) then
X      begin
X        emit1(floatleft2);
X        pop(1); push(2);
X        type1 := typereal
X      end
X   else convert1(type2, type1)
end;
X
{ VARIABLE ADDRESSING }
X
function typelength(
X  typex: pointer) : integer;
begin
X  if typex^.kind = ordtype
X    then typelength := 1
X  else if typex^.kind = realtype
X    then typelength := 2
X  else if typex^.kind = arraytype
X    then typelength :=
X      typex^.arraylength
X  else if typex^.kind = recordtype
X    then typelength :=
X      typex^.recordlength
X  else
X    { typex^.kind = channeltype }
X      typelength := 1
end;
X
procedure fieldaddressing(
X  recordlength: integer;
X  lastfield: pointer);
var displ: integer;
begin
X  displ := recordlength;
X  while displ > 0 do
X    begin
X      { skip undefined
X        object (if any) }
X      if lastfield^.kind = field
X        then
X          begin
X            displ := displ -
X              typelength(lastfield^.
X                fieldtype);
X            lastfield^.fielddispl
X              := displ
X          end;
X      lastfield :=
X        lastfield^.previous
X    end
end;
X
procedure variableaddressing(
X  varlength: integer;
X  lastvar: pointer);
var displ: integer;
begin
X  displ := varlength;
X  while displ > 0 do
X    begin
X      { skip undefined
X        object (if any) }
X      if lastvar^.kind = variable
X        then
X          begin
X            displ := displ -
X              typelength(
X                lastvar^.vartype);
X            lastvar^.varlevel :=
X              blocklevel;
X            lastvar^.vardispl :=
X              displ
X          end;
X      lastvar := lastvar^.previous
X    end
end;
X
procedure parameteraddressing(
X  paramlength: integer;
X  lastparam: pointer);
var displ: integer;
begin
X  displ := 0;
X  while displ > - paramlength do
X    begin
X      { skip undefined
X        object (if any) }
X      if lastparam^.kind =
X          varparameter then
X        begin
X          displ := displ - 1;
X          lastparam^.varlevel :=
X            blocklevel;
X          lastparam^.vardispl :=
X            displ
X        end
X      else if lastparam^.kind =
X          valueparameter then
X        begin
X          displ := displ -
X            typelength(
X              lastparam^.vartype);
X          lastparam^.varlevel :=
X            blocklevel;
X          lastparam^.vardispl :=
X            displ
X        end;
X      lastparam :=
X        lastparam^.previous
X    end
end;
X
{ LABELS }
X
procedure newlabel(
X  var no: integer);
begin
X  if labelno = maxlabel then
X    halt(maxlabel5);
X  labelno := labelno + 1;
X  no := labelno
end;
X
{ TEMPORARIES }
X
procedure push{length: integer};
begin
X  with block[blocklevel] do
X    begin
X      templength :=
X        templength + length;
X      if maxtemp < templength then
X        maxtemp := templength
X    end
end;
X
procedure pop{length: integer};
begin
X  with block[blocklevel] do
X    templength :=
X      templength - length
end;
X
{ CASE TABLES }
X
procedure insertcase(
X  value, index: integer;
X  var length: integer;
X  var table: casetable;
X  var found: boolean);
var x, y: caserecord;
X  i: integer;
begin
X  { 0 <= length < maxcase
X    and table ordered by
X    case values }
X  x.value := value;
X  x.index := index;
X  found := false;
X  for i := 1 to length do
X    begin
X      y := table[i];
X      if x.value < y.value
X        then
X          begin
X            table[i] := x;
X            x := y
X          end
X      else
X        if x.value = y.value
X          then found := true
X     end;
X  length := length + 1;
X  table[length] := x
end;
X
{ INITIALIZATION }
X
procedure initialize;
begin
X  addtokens :=
X    [minus1, or1, plus1];
X  declarationtokens :=
X    [const1, function1,
X     procedure1, type1, var1];
X  blocktokens := [begin1]
X    + declarationtokens;
X  doubletokens := [charconst1,
X    intconst1, identifier1];
X  literaltokens :=
X    [charconst1, intconst1,
X     realconst1, stringconst1];
X  longtokens := [realconst1,
X    stringconst1] + doubletokens;
X  multiplytokens :=
X    [and1, asterisk1, div1,
X     mod1, slash1];
X  parametertokens :=
X    [identifier1, var1];
X  relationtokens := [equal1,
X    greater1, less1, notequal1,
X    notgreater1, notless1];
X  routinetokens :=
X    [function1, procedure1];
X  selectortokens :=
X    [leftbracket1, period1];
X  signtokens := [minus1, plus1];
X  statementtokens :=
X    [assume1, begin1, case1,
X     for1, forall1, if1,
X     identifier1, leftbracket1,
X     parallel1, repeat1, while1];
X  unsignedtokens := [identifier1]
X    + literaltokens;
X  constanttokens := signtokens
X    + unsignedtokens;
X  factortokens := [leftparenthesis1,
X    not1] + unsignedtokens;
X  termtokens := factortokens;
X  simpleexprtokens := signtokens
X    + termtokens;
X  expressiontokens :=
X    simpleexprtokens;
X  constants := [ordconst, realconst,
X    stringconst];
X  functions :=
X    [funktion, standardfunc];
X  parameters := [valueparameter,
X    varparameter];
X  procedures :=
X    [procedur, standardproc];
X  types := [ordtype, realtype,
X    arraytype, recordtype,
X    channeltype];
X  variables :=
X    [variable] + parameters;
X  leftparts :=
X    [funktion] + variables;
X  labelno := 0;
X  minint := - maxint - 1
end;
X
{ SYNTAX ANALYSIS }
X
procedure syntaxerror(
X  stop: tokens);
begin
X  error(syntax3);
X  while not (token in stop) do
X    nexttoken
end;
X
procedure syntaxcheck(
X  stop: tokens);
begin
X  if not (token in stop) then
X    syntaxerror(stop)
end;
X
procedure expect(t: integer;
X  stop: tokens);
begin
X  if token = t then
X    begin
X      nexttoken;
X      syntaxcheck(stop)
X    end
X  else syntaxerror(stop)
end;
X
procedure expectid(
X  var id: integer;
X  stop: tokens);
begin
X  if token = identifier1 then
X    begin
X      id := argument;
X      nexttoken
X    end
X  else
X    begin
X      id := nameless;
X      syntaxerror(stop)
X    end;
X  syntaxcheck(stop)
end;
X
{ TypeIdentifier =
X    Identifier . }
X
procedure typeidentifier(
X  var typex: pointer;
X  stop: tokens);
var object: pointer;
begin
X  if token = identifier1 then
X    begin
X      find(argument, object);
X      if object^.kind in types
X      then typex := object
X      else
X        begin
X          kinderror(object);
X          typex := typeuniversal
X        end
X    end
X  else typex := typeuniversal;
X  expect(identifier1, stop)
end;
X
{ UnsignedOrdinal =
X    CharacterConstant |
X      UnsignedInteger |
X        ConstantIdentifier . }
X
procedure unsignedordinal(
X  var value: integer;
X  var typex: pointer;
X  stop: tokens);
var object: pointer;
begin
X  if token = charconst1 then
X    begin
X      value := argument;
X      typex := typechar;
X      expect(token, stop)
X    end
X  else if token = intconst1 then
X    begin
X      value := argument;
X      typex := typeinteger;
X      expect(token, stop)
X    end
X  else if token = identifier1 then
X    begin
X      find(argument, object);
X      if object^.kind = ordconst
X      then
X        begin
X          value := object^.ordvalue;
X          typex := object^.ordtypex
X        end
X      else
X        begin
X          kinderror(object);
X          value := 0;
X          typex := typeuniversal
X        end;
X      expect(identifier1, stop)
X    end
X  else
X    begin
X      syntaxerror(stop);
X      value := 0;
X      typex := typeuniversal
X    end
end;
X
{ UnsignedConstant =
X    UnsignedOrdinal |
X    UnsignedReal |
X    StringConstant |
X    ConstantIdentifier . }
X
procedure unsignedconstant(
X  var value: integer;
X  var realvalue: real;
X  var stringvalue: string;
X  var typex: pointer;
X  stop: tokens);
var object: pointer;
begin
X  { returns the type of an
X    unsigned constant and
X    its ordinal, real or
X    string value }
X  if token = realconst1 then
X    begin
X      realvalue := realarg;
X      typex := typereal;
X      expect(token, stop)
X    end
X  else if token = stringconst1
X    then
X      begin
X        stringvalue := stringarg;
X        typex := typestring;
X        expect(token, stop)
X      end
X  else if token = identifier1 then
X    begin
X      find(argument, object);
X      if object^.kind = realconst
X          then
X        begin
X          realvalue :=
X            object^.realvalue;
X          typex := typereal;
X          expect(identifier1, stop)
X        end
X      else
X        if object^.kind = stringconst
X      then
X        begin
X          stringvalue :=
X            object^.stringptr^;
X          typex := typestring;
X          expect(identifier1, stop)
X        end
X      else
X         unsignedordinal(value,
X           typex, stop)
X    end
X  else
X    unsignedordinal(value, typex,
X      stop)
end;
X
{ Constant =
X    [ Sign ] UnsignedConstant .
X  Sign =
X    "+" | "-" . }
X
procedure constant(
X  var value: integer;
X  var realvalue: real;
X  var stringvalue: string;
X  var typex: pointer;
X  stop: tokens);
var sign: integer;
begin
X  syntaxcheck(constanttokens
X    + stop);
X  if token in signtokens then
X    begin
X      sign := token;
X      expect(sign, unsignedtokens
X        + stop);
X      unsignedconstant(value,
X        realvalue, stringvalue,
X        typex, stop);
X      if typex = typeinteger then
X        if sign = minus1 then
X          if value <> maxint then
X            value := - value
X          else error(number3)
X        else { sign = plus1 }
X      else if typex = typereal then
X        if sign = minus1 then
X          realvalue := - realvalue
X        else { skip }
X      else
X        begin
X          typeerror(typex);
X          value := 0
X        end
X    end
X  else
X    unsignedconstant(value,
X      realvalue, stringvalue,
X      typex, stop)
end;
X
{ OrdinalConstant =
X    Constant . }
X
procedure ordinalconstant(
X  var value: integer;
X  var typex: pointer;
X  stop: tokens);
var realvalue: real;
X  stringvalue: string;
begin
X  constant(value, realvalue,
X    stringvalue, typex, stop);
X  if typex^.kind <> ordtype then
X    begin
X      typeerror(typex);
X      value := 0
X    end
end;
X
{ ConstantDefinition =
X    ConstantIdentifier
X      "=" Constant . }
X
procedure constantdefinition(
X  stop: tokens);
var id, value: integer;
X  realvalue: real;
X  stringvalue: string;
X  constx, typex: pointer;
X  stop2: tokens;
begin
X  stop2 := constanttokens + stop;
X  expectid(id, [equal1] + stop2);
X  expect(equal1, stop2);
X  constant(value, realvalue,
X    stringvalue, typex, stop);
X  if typex^.kind = ordtype then
X    begin
X      declare(id, ordconst, constx);
X      constx^.ordvalue := value;
X      constx^.ordtypex := typex
X    end
X  else if typex = typereal then
X    begin
X      declare(id, realconst, constx);
X      constx^.realvalue :=
X        realvalue
X    end
X  else { typex = typestring }
X    begin
X      declare(id, stringconst,
X        constx);
X      new(constx^.stringptr);
X      constx^.stringptr^ :=
X        stringvalue
X    end
end;
X
{ ConstantDefinitions =
X    "const" ConstantDefinition ";"
X      [ ConstantDefinition ";" ]*
X        . }
X
procedure constantdefinitions(
X  stop: tokens);
var stop2, stop3: tokens;
begin
X  stop2 := [identifier1] + stop;
X  stop3 := [semicolon1] + stop2;
X  expect(const1, stop3);
X  constantdefinition(stop3);
X  expect(semicolon1, stop2);
X  while token = identifier1 do
X    begin
X      constantdefinition(stop3);
X      expect(semicolon1, stop2)
X    end
end;
X
{ NewConstantList =
X    ConstantIdentifier [ ","
X      NewConstantList ] . }
X
procedure newconstantlist(
X  value: integer;
X  typex: pointer;
X  stop: tokens);
var constx: pointer;
X  id: integer;
begin
X  expectid(id, [comma1]
X    + stop);
X  declare(id, ordconst, constx);
X  constx^.ordvalue := value;
X  constx^.ordtypex := typex;
X  if token = comma1 then
X    begin
X      expect(comma1,
X        [identifier1] + stop);
X      newconstantlist(
X        value + 1, typex, stop)
X    end
X  else
X    begin
X      typex^.minvalue := 0;
X      typex^.maxvalue := value
X    end
end;
X
{ EnumeratedType =
X    "(" NewConstantList ")" . }
X
procedure enumeratedtypex(
X  id: integer; stop: tokens);
var newtype: pointer;
X  stop2: tokens;
begin
X  stop2 :=
X    [rightparenthesis1] + stop;
X  declare(id, ordtype, newtype);
X  expect(leftparenthesis1,
X    [identifier1] + stop2);
X  newconstantlist(0, newtype,
X    stop2);
X  expect(rightparenthesis1,
X    stop)
end;
X
{ IndexRange =
X    "[" OrdinalConstant ".."
X      OrdinalConstant "]" .  }
X
procedure indexrange(
X  var lowerbound, upperbound:
X    integer;
X  var indextype: pointer;
X  stop: tokens);
var stop2, stop3: tokens;
X  uppertype: pointer;
begin
X  stop2 := [rightbracket1] + stop;
X  stop3 := constanttokens + stop2;
X  expect(leftbracket1,
X    [doubledot1] + stop3);
X  ordinalconstant(
X    lowerbound, indextype,
X    [doubledot1] + stop3);
X  expect(doubledot1, stop3);
X  ordinalconstant(upperbound,
X    uppertype, stop2);
X  checktypes(indextype, uppertype);
X  if lowerbound > upperbound then
X    begin
X      error(range3);
X      lowerbound := upperbound
X    end;
X  expect(rightbracket1, stop)
end;
X
{ ArrayType =
X    "array" IndexRange "of"
X      TypeIdentifier . }
X
procedure arraytypex(id: integer;
X  stop: tokens);
var newtype, indextype,
X  elementtype: pointer;
X  lowerbound, upperbound: integer;
X  stop2, stop3: tokens;
begin
X  stop2 := [identifier1] + stop;
X  stop3 := [of1] + stop2;
X  expect(array1, [leftbracket1]
X    + stop3);
X  indexrange(lowerbound, upperbound,
X    indextype, stop3);
X  expect(of1, stop2);
X  typeidentifier(elementtype, stop);
X  declare(id, arraytype, newtype);
X  newtype^.lowerbound := lowerbound;
X  newtype^.upperbound := upperbound;
X  newtype^.arraylength :=
X    (upperbound - lowerbound + 1) *
X      typelength(elementtype);
X  newtype^.indextype := indextype;
X  newtype^.elementtype :=
X    elementtype
end;
X
{ RecordSection =
X    FieldIdentifier SectionTail .
X  SectionTail =
X    "," RecordSection |
X    ":" TypeIdentifier . }
X
procedure recordsection(
X  var number: integer;
X  var lastfield, typex: pointer;
X  stop: tokens);
var id: integer; fieldx: pointer;
X  stop2: tokens;
begin
X  stop2 := [identifier1] + stop;
X  expectid(id, [comma1, colon1]
X    + stop);
X  declare(id, field, fieldx);
X  if token = comma1 then
X    begin
X      expect(comma1, stop2);
X      recordsection(number,
X        lastfield, typex, stop);
X      number := number + 1
X    end
X  else
X    begin
X      expect(colon1, stop2);
X      typeidentifier(typex, stop);
X      lastfield := fieldx;
X      number := 1
X    end;
X  fieldx^.fieldtype := typex
end;
X
{ FieldList =
X    RecordSection
X      [ ";" RecordSection ]*
X        [ ";" ] . }
X
procedure fieldlist(
X  var lastfield: pointer;
X  var length: integer;
X  stop: tokens);
var number: integer;
X  typex: pointer;
X  stop2: tokens;
begin
X  stop2 := [semicolon1] + stop;
X  recordsection(
X    number, lastfield,
X    typex, stop2);
X  length :=
X    number * typelength(typex);
X  while token = semicolon1 do
X    begin
X      { use "stop" here }
X      expect(semicolon1,
X        [identifier1] + stop);
X      if token = identifier1 then
X        begin
X          recordsection(
X            number, lastfield,
X            typex, stop2);
X          length :=
X            length + number *
X              typelength(typex)
X        end
X    end;
X  fieldaddressing(length,
X    lastfield)
end;
X
{ RecordType =
X    "record" FieldList "end" . }
X
procedure recordtypex(id: integer;
X  stop: tokens);
var newtype, lastfield: pointer;
X  length: integer; stop2: tokens;
begin
X  stop2 := [end1] + stop;
X  newblock(nil);
X  expect(record1, [identifier1]
X    + stop2);
X  fieldlist(lastfield, length,
X    stop2);
X  expect(end1, stop);
X  endblock;
X  declare(id, recordtype, newtype);
X  newtype^.recordlength := length;
X  newtype^.lastfield := lastfield
end;
X
{ MessageTypeIdentifier =
X    TypeIdentifier . }
X
procedure messagetypeidentifier(
X  var last: messagepointer;
X    stop: tokens);
var typex: pointer;
begin
X  typeidentifier(typex, stop);
X  new(last);
X  last^.previous := nil;
X  last^.typex := typex
end;
X
{ MessageTypeList =
X    MessageTypeIdentifier [ ","
X      MessageTypeIdentifier ]* . }
X
procedure messagetypelist(
X  var last: messagepointer;
X    stop: tokens);
var next: messagepointer;
X  stop2: tokens;
begin
X  stop2 := [comma1] + stop;
X  messagetypeidentifier(
X    last, stop2);
X  while token = comma1 do
X    begin
X      expect(comma1,
X        [identifier1] + stop2);
X      messagetypeidentifier(
X        next, stop2);
X      next^.previous := last;
X      last := next
X    end
end;
X
{ ChannelType =
X    "*" "(" MessageTypeList ")"
X      . }
X
procedure channeltypex(
X  id: integer; stop: tokens);
var stop2, stop3: tokens;
X  newtype: pointer;
X  last: messagepointer;
begin
X  stop2 := [rightparenthesis1]
X    + stop;
X  stop3 :=
X    [identifier1] + stop2;
X  expect(asterisk1,
X    [leftparenthesis1] + stop3);
X  expect(leftparenthesis1,
X    stop3);
X  messagetypelist(last, stop2);
X  expect(rightparenthesis1,
X    stop);
X  declare(id, channeltype,
X    newtype);
X  newtype^.messagelist := last
end;
X
{ TypeDefinition =
X    TypeIdentifier "=" NewType .
X  NewType =
X    EnumeratedType | ArrayType |
X    RecordType | ChannelType . }
X
procedure typedefinition(
X  stop: tokens);
var stop2: tokens; id: integer;
X  object: pointer;
begin
X  stop2 := [array1, asterisk1,
X    leftparenthesis1, record1]
X      + stop;
X  expectid(id, [equal1] + stop2);
X  expect(equal1, stop2);
X  if token = leftparenthesis1
X    then enumeratedtypex(id, stop)
X  else if token = array1
X    then arraytypex(id, stop)
X  else if token = record1
X    then recordtypex(id, stop)
X  else if token = asterisk1
X    then channeltypex(id, stop)
X  else
X    begin
X      declare(id, undefined, object);
X      syntaxerror(stop)
X    end
end;
X
{ TypeDefinitions =
X    "type" TypeDefinition ";"
X      [ TypeDefinition ";" ]* . }
X
procedure typedefinitions(
X  stop: tokens);
var stop2, stop3: tokens;
begin
X  stop2 := [identifier1] + stop;
X  stop3 := [semicolon1] + stop2;
X  expect(type1, stop3);
X  typedefinition(stop3);
X  expect(semicolon1, stop2);
X  while token = identifier1 do
X    begin
X      typedefinition(stop3);
X      expect(semicolon1, stop2)
X    end
end;
X
{ VariableDeclaration =
X    VariableIdentifier
X      VariableTail .
X  VariableTail =
X    "," VariableDeclaration |
X    ":" TypeIdentifier . }
X
procedure variabledeclaration(
X  kind: class; var number: integer;
X  var lastvar, typex: pointer;
X  stop: tokens);
var id: integer; varx: pointer;
X  stop2: tokens;
begin
X  stop2 := [identifier1] + stop;
X  expectid(id, [comma1, colon1]
X    + stop);
X  declare(id, kind, varx);
X  if token = comma1 then
X    begin
X      expect(comma1, stop2);
X      variabledeclaration(kind,
X        number, lastvar, typex,
X        stop);
X      number := number + 1
X    end
X  else
X    begin
X      expect(colon1, stop2);
X      typeidentifier(typex, stop);
X      lastvar := varx;
X      number := 1
X    end;
X  varx^.vartype := typex
end;
X
{ VariableDeclarations =
X    "var" VariableDeclaration ";"
X      [ VariableDeclaration ";" ]*
X        . }
X
procedure variabledeclarations(
X  var length: integer; stop: tokens);
var lastvar, typex: pointer;
X  number: integer;
X  stop2, stop3: tokens;
begin
X  stop2 := [identifier1] + stop;
X  stop3 := [semicolon1] + stop2;
X  expect(var1, stop3);
X  variabledeclaration(variable,
X    number, lastvar, typex, stop3);
X  length :=
X    number * typelength(typex);
X  expect(semicolon1, stop2);
X  while token = identifier1 do
X    begin
X      variabledeclaration(variable,
X        number, lastvar, typex,
X        stop3);
X      length := length +
X        number * typelength(typex);
X      expect(semicolon1, stop2)
X    end;
X  variableaddressing(length,
X    lastvar)
end;
X
{ FormalParameterSection =
X    [ "var" ]
X      VariableDeclaration . }
X
procedure formalparametersection(
X  proc: pointer;
X  var lastparam: pointer;
X  var length: integer;
X  stop: tokens);
var stop2: tokens; number: integer;
X  typex: pointer;
begin
X  stop2 := [identifier1] + stop;
X  syntaxcheck([var1] + stop2);
X  if token = var1 then
X    begin
X      expect(var1, stop2);
X      variabledeclaration(
X        varparameter, length,
X        lastparam, typex, stop);
X      if proc^.kind = funktion
X        then error(parameter3)
X    end
X  else
X    begin
X      variabledeclaration(
X        valueparameter, number,
X        lastparam, typex, stop);
X      length :=
X        number * typelength(typex)
X    end
end;
X
{ FormalParameters =
X    FormalParameterSection [ ";"
X      FormalParameterSection ]* . }
X
procedure formalparameters(
X  proc: pointer;
X  var lastparam: pointer;
X  var length: integer;
X  stop: tokens);
var more: integer; stop2: tokens;
begin
X  stop2 := [semicolon1] + stop;
X  formalparametersection(
X    proc, lastparam,
X    length, stop2); 
X  while token = semicolon1 do
X    begin
X      expect(semicolon1,
X        parametertokens + stop2);
X      formalparametersection(
X        proc, lastparam,
X        more, stop2);
X      length := length + more
X    end;
X  parameteraddressing(length,
X    lastparam)
end;
X
{ FormalParameterList =
X    "(" FormalParameters ")" . }
X
procedure formalparameterlist(
X  proc: pointer;
X  var lastparam: pointer;
X  var length: integer;
X  stop: tokens);
var stop2: tokens;
begin
X  stop2 := [rightparenthesis1]
X    + stop;
X  expect(leftparenthesis1,
X    parametertokens + stop2);
X  formalparameters(proc,
X    lastparam, length, stop2);
X  expect(rightparenthesis1, stop)
end;
X
{ FormalParameterPart =
X    [ FormalParameterList ] . }
X
procedure formalparameterpart(
X  proc: pointer;
X  var lastparam: pointer;
X  var length: integer;
X  stop: tokens);
begin
X  syntaxcheck([leftparenthesis1]
X    + stop);
X  if token = leftparenthesis1
X    then
X      formalparameterlist(
X        proc, lastparam,
X        length, stop)
X    else { no parameter list }
X      begin
X        lastparam := nil;
X        length := 0
X      end
end;
X
{ FunctionHeading =
X    "function" FunctionIdentifier
X      FormalParameterPart ":"
X        TypeIdentifier . }
X
procedure functionheading(
X  var proc: pointer;
X  stop: tokens);
var stop2, stop3: tokens;
X  id: integer;
begin
X  stop2 := [identifier1] + stop;
X  stop3 := [colon1] + stop2;
X  expect(function1,
X    [leftparenthesis1] + stop3);
X  expectid(id, [leftparenthesis1]
X    + stop3);
X  declare(id, funktion, proc);
X  proc^.proclevel := blocklevel;
X  newlabel(proc^.proclabel);
X  newblock(proc);
X  formalparameterpart(
X    proc, proc^.lastparam,
X    proc^.paramlength, stop3);
X  expect(colon1, stop2);
X  typeidentifier(
X    proc^.resulttype, stop)
end;
X
{ ProcedureBlock =
X    Block .
X  Block =
X    DeclarationPart
X      StatementPart . }
X
procedure procedureblock(
X  proc: pointer; stop: tokens);
var implicit, used: context;
X  varlabel, templabel,
X  beginlabel, templength:
X    integer;
begin
X  newlabel(varlabel);
X  newlabel(templabel);
X  newlabel(beginlabel);
X  emit2(defaddr2,
X    proc^.proclabel);
X  emit6(procedure2,
X    proc^.paramlength,
X    varlabel, templabel,
X    beginlabel, lineno);
X  proc^.recursive := false;
X  newcontext(proc^.implicit);
X  declarationpart(
X    proc^.varlength,
X    [begin1] + stop);
X  emit3(defarg2, varlabel,
X    proc^.varlength);
X  emit2(defaddr2, beginlabel);
X  statementpart(templength,
X    used, stop);
X  globalcontext(proc,
X    implicit, used);
X  if (proc^.kind = funktion)
X      and not
X    empty(implicit.targetvar)
X      then error(parameter3)
X  else if proc^.recursive
X      and not
X    emptycontext(implicit)
X      then error(recursion3)
X  else
X    proc^.implicit := implicit;
X  emit3(defarg2, templabel,
X    templength);
X  emit1(endproc2);
X  endblock
end;
X
{ FunctionDeclaration =
X    FunctionHeading ";"
X      ProcedureBlock . }
X
procedure functiondeclaration(
X  stop: tokens);
var proc: pointer; stop2: tokens;
begin
X  stop2 := blocktokens + stop;
X  functionheading(proc,
X    [semicolon1] + stop2);
X  expect(semicolon1, stop2);
X  procedureblock(proc, stop)
end;
X
{ ProcedureHeading =
X    "procedure"
X      ProcedureIdentifier
X        FormalParameterPart . }
X
procedure procedureheading(
X  var proc: pointer;
X  stop: tokens);
var id: integer; stop2: tokens;
begin
X  stop2 :=
X    [leftparenthesis1] + stop;
X  expect(procedure1,
X    [identifier1] + stop2);
X  expectid(id, stop2);
X  declare(id, procedur, proc);
X  proc^.proclevel := blocklevel;
X  newlabel(proc^.proclabel);
X  newblock(proc);
X  formalparameterpart(
X    proc, proc^.lastparam,
X    proc^.paramlength, stop);
X  proc^.resulttype := nil
end;
X
{ ProcedureDeclaration =
X    ProcedureHeading ";"
X      ProcedureBlock. }
X
procedure proceduredeclaration(
X  stop: tokens);
var proc: pointer;
X  stop2: tokens;
begin
X  stop2 := blocktokens + stop;
X  procedureheading(proc,
X    [semicolon1] + stop2);
X  expect(semicolon1, stop2);
X  procedureblock(proc, stop)
end;
X
{ RoutineDeclarationPart =
X    [ FunctionDeclaration ";" |
X      ProcedureDeclaration ";"
X        ]* . }
X
procedure routinedeclarationpart(
X  stop: tokens);
var stop2, stop3: tokens;
begin
X  stop2 := routinetokens + stop;
X  stop3 := [semicolon1] + stop2;
X  syntaxcheck(stop2);
X  while token in routinetokens do
X    begin
X      if token = function1 then
X        functiondeclaration(stop3)
X      else { symbol = procedure1 }
X        proceduredeclaration(stop3);
X      expect(semicolon1, stop2)
X    end
end;
X
{ DeclarationPart =
X    [ ConstantDefinitions ]
X      [ TypeDefinitions ]
X        [ VariableDeclarations ]
X          RoutineDeclarationPart . }
X
procedure declarationpart{
X  var varlength: integer;
X  stop: tokens};
var stop2: tokens;
begin
X  stop2 := routinetokens + stop;
X  syntaxcheck(declarationtokens
X    + stop);
X  if token = const1 then
X    constantdefinitions(
X      [type1, var1] + stop2);
X  if token = type1 then
X    typedefinitions([var1] + stop2);
X  if token = var1 then
X    variabledeclarations(varlength,
X      stop2)
X  else varlength := 0;
X  routinedeclarationpart(stop)
end;
X
{ IndexExpression =
X    Expression . }
X
procedure indexexpression(
X  var typex: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var exprtype: pointer;
begin
X  expression(exprtype, used,
X    restricted, stop);
X  if typex^.kind = arraytype then
X    begin
X      checktypes(exprtype,
X        typex^.indextype);
X      emit5(index2,
X        typex^.lowerbound,
X        typex^.upperbound,
X        typelength(
X          typex^.elementtype),
X        lineno);
X      pop(1);
X      typex := typex^.elementtype
X    end
X  else
X    begin
X      kinderror(typex);
X      typex := typeuniversal
X    end
end;
X
{ IndexExpressions =
X    IndexExpression
X      [ "," IndexExpression ]* . }
X
procedure indexexpressions(
X  var typex: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var used2: context; stop2: tokens;
begin
X  stop2 := [comma1] + stop;
X  indexexpression(typex, used,
X    restricted, stop2);
X  while token = comma1 do
X    begin
X      expect(comma1,
X        expressiontokens + stop2);
X      indexexpression(typex, used2,
X        restricted, stop2);
X      addcontext(used, used2)
X    end
end;
X
{ IndexedSelector =
X    "[" IndexExpressions "]" . }
X
procedure indexedselector(
X  var typex: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var stop2: tokens;
begin
X  stop2 := [rightbracket1] + stop;
X  expect(leftbracket1,
X    expressiontokens + stop2);
X  indexexpressions(typex, used,
X    restricted, stop2);
X  expect(rightbracket1, stop)
end;
X
{ FieldSelector =
X    "." FieldIdentifier . }
X
procedure fieldselector(
X  var typex: pointer;
X  stop: tokens);
var found: boolean;
X  fieldx: pointer;
begin
X  expect(period1, [identifier1]
X    + stop);
X  if token = identifier1 then
X    begin
X      if typex^.kind = recordtype
X          then
X        begin
X          found := false;
X          fieldx :=
X            typex^.lastfield;
X          while not found and
X              (fieldx <> nil) do
X            if fieldx^.id =
X              argument
X                then
X                  found := true
X                else
X                  fieldx :=
X                    fieldx^.
X                      previous;
X          if found then
X            begin
X              typex :=
X                fieldx^.
X                  fieldtype;
X              emit2(field2,
X                fieldx^.
X                  fielddispl)
X            end
X          else
X            begin
X              error(undefined3);
X              typex :=
X                typeuniversal
X            end
X        end
X      else
X        begin
X          kinderror(typex);
X          typex := typeuniversal
X        end;
X      expect(identifier1, stop)
X    end
X  else
X    begin
X      syntaxerror(stop);
X      typex := typeuniversal
X    end
end;
X
{ EntireVariableAccess =
X    VariableIdentifier . }
X
procedure entirevariableaccess(
X  var typex: pointer;
X  var used: context;
X  target: boolean;
X  stop: tokens);
var level, displ: integer;
X  object: pointer; 
begin
X  newcontext(used);
X  if token = identifier1 then
X    begin
X      find(argument, object);
X      expect(identifier1, stop);
X      if object^.kind in variables
X        then
X          begin
X            typex :=
X              object^.vartype;
X            level := blocklevel -
X              object^.varlevel;
X            displ :=
X              object^.vardispl;
X            if object^.kind =
X              varparameter
X                then
X                  emit3(varparam2,
X                    level, displ)
X                else
X                  emit3(variable2,
X                    level, displ);
X            if target then
X              include(
X                used.targetvar,
X                object)
X            else
X              include(
X                used.exprvar,
X                object);
X            push(1)
X          end
X      else
X        begin
X          kinderror(object);
X          typex := typeuniversal
X        end
X    end
X  else
X    begin
X      syntaxerror(stop);
X      typex := typeuniversal
X    end
end;
X
{ VariableAccess =
X    EntireVariableAccess
X      [ ComponentSelector ]* .
X  ComponentSelector =
X    IndexedSelector |
X    FieldSelector . }
X
procedure variableaccess(
X  var typex: pointer;
X  var used: context;
X  target, restricted: boolean;
X  stop: tokens);
var used2: context;
X  stop2: tokens;
begin
X  stop2 :=
X    selectortokens + stop;
X  entirevariableaccess(
X    typex, used, target,
X    stop2);
X  while token in
X    selectortokens do
X      if token = leftbracket1
X        then
X          begin
X            indexedselector(
X              typex, used2,
X              restricted,
X              stop2);
X            addcontext(used,
X              used2)
X           end
X         else
X           { token = period1 }
X           fieldselector(
X             typex, stop2)
end;
X
{ FileFunctionDesignator =
X    "eof" | "eoln" . }
X
procedure filefunctiondesignator(
X  var typex: pointer;
X  var used: context;
X  stop: tokens);
var id: integer;
begin
X  { symbol = (file function)
X      identifier }
X  newcontext(used);
X  include(used.exprvar,
X    inputfile);
X  expectid(id, stop);
X  if id = eof0 then
X    emit2(eof2, lineno)
X  else { id = eoln0 }
X    emit2(eoln2, lineno);
X  push(1);
X  typex := typeboolean
end;
X
{ MathFunctionDesignator =
X    MathFunctionIdentifier
X      "(" Expression ")" .
X  MathFunctionIdentifier =
X    "abs" | "arctan" | "chr" |
X    "cos" | "exp" | "ln" |
X    "odd" | "ord" | "pred" |
X    "round" | "sin" | "sqr" |
X    "sqrt" | "succ" | "trunc". }
X
procedure mathfunctiondesignator(
X  var typex: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var stop2, stop3: tokens;
X  exprtype: pointer;
X  id: integer;
begin
X  { token = (math function)
X      identifier }
X  stop2 :=
X    [rightparenthesis1] + stop;
X  stop3 :=
X    expressiontokens + stop2;
X  expectid(id, [leftparenthesis1]
X    + stop3);
X  expect(leftparenthesis1,
X    stop3);
X  expression(exprtype, used,
X    restricted, stop2);
X  case id of
X    arctan0, cos0, exp0, ln0,
X      sin0, sqrt0:
X        begin
X          convert1(exprtype,
X            typereal);
X          checktypes(exprtype,
X            typereal);
X          if id = arctan0 then
X            emit2(arctan2, lineno)
X          else if id = cos0 then
X            emit2(cos2, lineno)
X          else if id = exp0 then
X            emit2(exp2, lineno)
X          else if id = ln0 then
X            emit2(ln2, lineno)
X          else if id = sin0 then
X            emit2(sin2, lineno)
X          else { id = sqrt0 }
X            emit2(sqrt2, lineno);
X          typex := typereal
X        end;
X    abs0, sqr0:
X      begin
X        if exprtype = typeinteger
X          then
X            if id = abs0 then
X              emit2(absint2,
X                lineno)
X            else { id = sqr0 }
X              emit2(sqrint2,
X                lineno)
X          else
X            begin
X              checktypes(exprtype,
X                typereal);
X              if id = abs0 then
X                emit2(abs2, lineno)
X              else { id = sqr0 }
X                emit2(sqr2, lineno)
X            end;
X        typex := exprtype
X      end;
X    odd0:
X      begin
X        checktypes(exprtype,
X          typeinteger);
X        typex := typeboolean;
X        emit1(odd2)
X      end;
X    ord0:
X      begin
X        checktype(exprtype,
X          ordtype);
X        typex := typeinteger
X      end;
X    pred0, succ0:
X      begin
X        checktype(exprtype,
X          ordtype);
X        if id = pred0 then
X          emit3(pred2,
X            exprtype^.minvalue,
X            lineno)
X        else { id = succ0 }
X          emit3(succ2,
X            exprtype^.maxvalue,
X            lineno);
X        typex := exprtype
X      end;
X    chr0:
X      begin
X        checktypes(exprtype,
X          typeinteger);
X        emit2(chr2, lineno);
X        typex := typechar
X      end;
X    round0, trunc0:
X      begin
X        convert1(exprtype,
X          typereal);
X        checktypes(exprtype,
X          typereal);
X        if id = round0 then
X          emit2(round2, lineno)
X        else { id = trunc0 }
X          emit2(trunc2, lineno);
X        typex := typeinteger
X      end
X  end;
X  expect(rightparenthesis1,
X    stop);
X  pop(typelength(exprtype));
X  push(typelength(typex))
end;
X
{ StandardFunctionDesignator =
X    FileFunctionDesignator |
X    MathFunctionDesignator . }
X
procedure
X  standardfunctiondesignator(
X    var typex: pointer;
X    var used: context;
X    restricted: boolean;
X    stop: tokens);
{ access restrictions always
X  satisfied }
begin
X  { token = (standard function)
X      identifier }
X  if argument in [eof0, eoln0]
X    then
X      filefunctiondesignator(
X        typex, used, stop)
X    else
X      mathfunctiondesignator(
X        typex, used, restricted,
X        stop)
end;
X
{ ActualParameters =
X    [ ActualParameters "," ]
X      ActualParameter .
X  ActualParameter =
X    Expression |
X    VariableAccess . }
X
procedure actualparameters(
X  lastparam: pointer;
X  var length: integer;
X  var distinct: varset;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var typex: pointer;
X  more: integer;
X  used2: context;
X  stop2: tokens;
begin
X  { lastparam <> nil }
X  if lastparam^.previous <> nil
X    then
X      begin
X        stop2 :=
X          expressiontokens
X            + stop;
X        actualparameters(
X          lastparam^.previous,
X          more, distinct,
X          used, restricted,
X          [comma1] + stop2);
X        expect(comma1, stop2)
X      end
X  else more := 0;
X  if lastparam^.kind =
X    valueparameter then
X      begin
X        expression(typex, used2,
X          restricted, stop);
X        addcontext(used, used2);
X        convert1(typex,
X          lastparam^.vartype);
X        length :=
X          typelength(typex)
X            + more
X      end
X    else
X    { lastparam^.kind =
X        varparameter }
X      begin
X        variableaccess(
X          typex, used2, true,
X          restricted, stop);
X        if restricted and not
X          disjoint(distinct,
X            used2.targetvar)
X          then error(procedure3);
X        addset(distinct,
X          used2.targetvar);
X        addcontext(used, used2);
X        length := 1 + more
X      end;
X  checktypes(typex,
X    lastparam^.vartype)
end;
X
{ ActualParameterPart =
X    [ ActualParameterList ] .
X  ActualParameterList =
X    "(" ActualParameters ")" . }
X
procedure actualparameterpart(
X  proc: pointer;
X  var length: integer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var distinct: varset;
X  stop2: tokens;
begin
X  copycontext(used,
X    proc^.implicit);
X  if proc^.lastparam <> nil then
X    begin
X      stop2 :=
X        [rightparenthesis1]
X          + stop;
X      expect(leftparenthesis1,
X        expressiontokens
X          + stop2);
X      copyset(distinct,
X        used.exprvar);
X      addset(distinct,
X        used.targetvar);
X      actualparameters(
X        proc^.lastparam,
X        length, distinct,
X        used, restricted,
X        stop2);
X      expect(rightparenthesis1,
X        stop)
X    end
X  else { no parameter list }
X    begin
X      length := 0;
X      syntaxcheck(stop)
X    end
end;
X
{ FunctionDesignator =
X    FunctionIdentifier
X      ActualParameterPart |
X    StandardFunctionDesignator
X      . }
X
procedure functiondesignator(
X  var typex: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var proc: pointer; paramlength,
X  resultlength: integer;
begin
X  { token = (function)
X      identifier }
X  find(argument, proc);
X  if proc^.kind = standardfunc
X    then
X      standardfunctiondesignator(
X        typex, used, restricted,
X        stop)
X    else
X      begin
X        expect(identifier1,
X          [leftparenthesis1]
X            + stop);
X        typex :=
X          proc^.resulttype;
X        resultlength :=
X          typelength(typex);
X        emit2(result2,
X          resultlength);
X        push(resultlength);
X        actualparameterpart(
X          proc, paramlength,
X          used, restricted,
X          stop);
X        if within(proc) then
X          proc^.recursive :=
X            true;
X        emit3(proccall2,
X          blocklevel -
X            proc^.proclevel,
X          proc^.proclabel);
X        push(proc^.varlength);
X        pop(proc^.paramlength
X          + proc^.varlength)
X      end
end;
X
{ Factor =
X    UnsignedConstant |
X    VariableAccess |
X    FunctionDesignator |
X    "(" Expression ")" |
X    "not" Factor . }
X
procedure factor(
X  var typex: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var length, value: integer;
X  object: pointer;
X  realvalue: real;
X  stringvalue: string;
X  stop2: tokens;
begin
X  if token in literaltokens then
X    begin
X      newcontext(used);
X      unsignedconstant(value,
X        realvalue, stringvalue,
X        typex, stop);
X      if typex^.kind = ordtype
X        then
X          emit2(ordconst2, value)
X      else if typex = typereal
X        then
X          emitreal(realvalue)
X      else { typex = typestring }
X        emitstring(stringvalue);
X      push(typelength(typex))
X    end
X  else if token = identifier1 then
X    begin
X      find(argument, object);
X      if object^.kind in constants
X          then
X        begin
X          newcontext(used);
X          unsignedconstant(value,
X            realvalue, stringvalue,
X            typex, stop);
X          if typex^.kind = ordtype
X            then
X              emit2(ordconst2,
X                value)
X          else if typex = typereal
X            then
X              emitreal(realvalue)
X          else
X            { typex = typestring }
X            emitstring(stringvalue);
X          push(typelength(typex))
X        end
X      else if object^.kind in
X        variables then
X          begin
X            variableaccess(
X              typex, used, false,
X              restricted, stop);
X            length :=
X              typelength(typex);
X            emit2(value2, length);
X            pop(1); push(length)
X          end
X      else if object^.kind in
X        functions then
X          functiondesignator(typex,
X            used, restricted, stop)
X      else
X        begin
X          newcontext(used);
X          kinderror(object);
X          typex := typeuniversal;
X          expect(identifier1,
X            stop)
X        end
X    end
X  else if token = leftparenthesis1
X      then
X    begin
X      stop2 := [rightparenthesis1]
X        + stop;
X      expect(leftparenthesis1,
X        expressiontokens + stop2);
X      expression(typex, used,
X        restricted, stop2);
X      expect(rightparenthesis1,
X        stop)
X    end
X  else if token = not1 then
X    begin
X      expect(not1,
X        factortokens + stop);
X      factor(typex, used,
X        restricted, stop);
X      checktypes(typex,
X        typeboolean);
X      emit1(not2)
X    end
X  else
X    begin
X      newcontext(used);
X      syntaxerror(stop);
X      typex := typeuniversal
X    end
end;
X
{ Term =
X    Factor [ MultiplyingOperator
X      Factor ]* .
X  MultiplyingOperator =
X    "*" | "/" | "div" | "mod" |
X    "and" . }
X
procedure term(
X  var typex: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var operator: integer;
X  type2: pointer;
X  used2: context;
X  stop2: tokens;
begin
X  stop2 := multiplytokens + stop;
X  factor(typex, used, restricted,
X    stop2);
X  while token in multiplytokens do
X    begin
X      operator := token;
X      expect(token, factortokens
X        + stop2);
X      factor(type2, used2,
X        restricted, stop2);
X      addcontext(used, used2);
X      convert2(typex, type2);
X      if typex = typeboolean then
X        begin
X          checktypes(typex, type2);
X          if operator = and1 then
X            emit1(and2)
X          else
X            { arithmetic operator }
X            typeerror(typex)
X        end
X      else if typex = typeinteger
X          then
X        begin
X          checktypes(typex, type2);
X          if operator = asterisk1
X            then 
X              emit2(multiply2,
X                lineno)
X          else
X            if operator = div1
X              then
X                emit2(divide2,
X                  lineno)
X          else
X            if operator = mod1
X              then
X                emit2(modulo2,
X                  lineno)
X          else { operator = and1 }
X            typeerror(typex)
X        end
X      else if typex = typereal then
X        begin
X          checktypes(typex, type2);
X          if operator = asterisk1
X            then
X              emit2(multreal2,
X                lineno)
X          else
X            if operator = slash1
X              then
X                emit2(divreal2,
X                  lineno)
X          else { operator in
X            [and1, div1, mod1] }
X              typeerror(typex)
X        end
X      else typeerror(typex);
X      pop(typelength(typex))
X    end
end;
X
{ SimpleExpression =
X    [ Sign ] Term
X       [ AddingOperator Term ]* .
X  AddingOperator =
X    "+" | "-" | "or" . }
X
procedure simpleexpression(
X  var typex: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var operator: integer;
X  type2: pointer;
X  used2: context;
X  stop2: tokens;
begin
X  stop2 := addtokens + stop;
X  syntaxcheck(signtokens
X    + termtokens + stop2);
X  if token in signtokens then
X    begin
X      operator := token;
X      expect(token, termtokens
X        + stop2);
X      term(typex, used,
X        restricted, stop2);
X      if typex = typeinteger then
X        if operator = minus1 then
X          emit2(minus2, lineno)
X        else { operator = plus1 }
X      else if typex = typereal then
X        if operator = minus1 then
X          emit2(minusreal2, lineno)
X        else { operator = plus1 }
X      else typeerror(typex)
X    end
X  else
X    term(typex, used, restricted,
X      stop2);
X  while token in addtokens do
X    begin
X      operator := token;
X      expect(token, termtokens
X        + stop2);
X      term(type2, used2,
X        restricted, stop2);
X      addcontext(used, used2);
X      convert2(typex, type2);
X      if typex = typeboolean then
X        begin
X          checktypes(typex, type2);
X          if operator = or1 then
X            emit1(or2)
X          else
X            { arithmetic operator }
X            typeerror(typex)
X        end
X      else if typex = typeinteger
X        then
X          begin
X            checktypes(typex,
X              type2);
X            if operator = plus1
X              then
X                emit2(add2, lineno)
X            else
X              if operator = minus1
X                then
X                  emit2(subtract2,
X                    lineno)
X            else { operator = or1 }
X              typeerror(typex)
X          end
X      else if typex = typereal then
X        begin
X          checktypes(typex, type2);
X          if operator = plus1 then
X            emit2(addreal2, lineno)
X          else
X            if operator = minus1
X              then
X                emit2(subreal2,
X                  lineno)
X          else { operator = or1 }
X            typeerror(typex)
X        end
X      else typeerror(typex);
X      pop(typelength(typex))
X    end
end;
X
{ Expression =
X    SimpleExpression
X      [ RelationalOperator
X        SimpleExpression ] .
X  RelationalOperator =
X    "<" | "=" | ">" |
X    "<=" | "<>" | ">=" . }
X
procedure expression{
X  typex: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens};
var length, operator: integer;
X  type2: pointer; used2: context;
begin
X  simpleexpression(typex,
X    used, restricted,
X    relationtokens + stop);
X  if token in relationtokens then
X    begin
X      operator := token;
X      expect(token, simpleexprtokens
X        + stop);
X      simpleexpression(type2, used2,
X        restricted, stop);
X      addcontext(used, used2);
X      convert2(typex, type2);
X      if typex^.kind = ordtype then
X        begin
X          checktypes(typex, type2);
X          if operator = less1
X            then emit1(lsord2)
X          else if operator = equal1
X            then emit1(eqord2)
X          else if operator = greater1
X            then emit1(grord2)
X          else
X            if operator = notgreater1
X              then emit1(ngord2)
X          else
X            if operator = notequal1
X              then emit1(neord2)
X          else
X            { operator = notless1 }
X              emit1(nlord2)
X        end
X      else if typex = typereal then
X        begin
X          checktypes(typex, type2);
X          if operator = less1
X            then emit1(lsreal2)
X          else if operator = equal1
X            then emit1(eqreal2)
X          else if operator = greater1
X            then emit1(grreal2)
X          else
X            if operator = notgreater1
X              then emit1(ngreal2)
X          else
X            if operator = notequal1
X              then emit1(nereal2)
X          else
X            { operator = notless1 }
X              emit1(nlreal2)
X        end
X      else if typex = typestring then
X        begin
X          checktypes(typex, type2);
X          if operator = less1
X            then emit1(lsstring2)
X          else if operator = equal1
X            then emit1(eqstring2)
X          else if operator = greater1
X            then emit1(grstring2)
X          else
X            if operator = notgreater1
X              then emit1(ngstring2)
X          else
X            if operator = notequal1
X              then emit1(nestring2)
X          else
X            { operator = notless1 }
X              emit1(nlstring2)
X        end
X      else { array, record or
X         channel type }
X        begin
X          checktypes(typex, type2);
X          length :=
X            typelength(typex);
X          if operator = equal1 then
X            emit2(equal2, length)
X          else
X            if operator = notequal1
X              then
X                emit2(notequal2,
X                  length)
X          else typeerror(typex)
X        end;
X      pop(2*typelength(typex));
X      push(1);
X      typex := typeboolean
X    end
end;
X
{ FunctionVariable =
X    FunctionIdentifier . }
X
procedure functionvariable(
X  var typex: pointer;
X  var used: context;
X  stop: tokens);
var proc: pointer;
begin
X  { token = (function)
X      identifier }
X  find(argument, proc);
X  newcontext(used);
X  if proc =
X      block[blocklevel].heading
X    then { in function block }
X      begin
X        typex := proc^.resulttype;
X        emit3(variable2, 0,
X          - proc^.paramlength
X            - typelength(typex));
X        include(used.targetvar,
X          proc);
X        push(1)
X      end
X    else
X      begin
X        kinderror(proc);
X        typex := typeuniversal
X      end;
X  expect(identifier1, stop)
end;
X
{ AssignmentStatement =
X    LeftPart ":=" Expression .
X  LeftPart =
X    VariableAccess |
X    FunctionVariable . }
X
procedure assignmentstatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var leftpart, lefttype,
X  exprtype: pointer;
X  length: integer;
X  used2: context;
X  stop2, stop3: tokens;
begin
X  { token = (left part)
X      identifier }
X  stop2 :=
X    expressiontokens + stop;
X  stop3 := [becomes1] + stop2;
X  find(argument, leftpart);
X  if leftpart^.kind in variables
X    then
X      variableaccess(lefttype,
X        used, true, restricted,
X        stop3)
X    else
X      functionvariable(
X        lefttype, used, stop3);
X  expect(becomes1, stop2);
X  expression(exprtype, used2,
X    restricted, stop);
X  addcontext(used, used2);
X  convert1(exprtype, lefttype);
X  checktypes(lefttype, exprtype);
X  length := typelength(exprtype);
X  emit2(assign2, length);
X  pop(1 + length)
end;
X
{ ReadParameter =
X    VariableAccess . }
X
procedure readparameter(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var typex: pointer;
begin
X  variableaccess(typex, used,
X    true, restricted, stop);
X  include(used.targetvar,
X    inputfile);
X  if typex = typechar then
X    emit2(read2, lineno)
X  else if typex = typeinteger then
X    emit2(readint2, lineno)
X  else if typex = typereal then
X    emit2(readreal2, lineno)
X  else typeerror(typex);
X  pop(1)
end;
X
{ ReadParameters =
X    ReadParameter
X      [ "," ReadParameter ]* . }
X
procedure readparameters(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var used2: context; stop2: tokens;
begin
X  stop2 := [comma1] + stop;
X  readparameter(used,
X    restricted, stop2);
X  while token = comma1 do
X    begin
X      expect(comma1,
X        [identifier1] + stop2);
X      readparameter(used2,
X        restricted, stop2);
X      addcontext(used, used2)
X    end
end;
X
{ ReadParameterList =
X    "(" ReadParameters ")" . }
X
procedure readparameterlist(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var stop2: tokens;
begin
X  stop2 :=
X    [rightparenthesis1] + stop;
X  expect(leftparenthesis1,
X    [identifier1] + stop2);
X  readparameters(used,
X    restricted, stop2);
X  expect(rightparenthesis1, stop)
end;
X
{ ReadStatement =
X    "read" ReadParameterList |
X    "readln"
X       [ ReadParameterList ] . }
X
procedure readstatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var id: integer;
begin
X  { token = (read procedure)
X      identifier }
X  expectid(id, [leftparenthesis1]
X    + stop);
X  if id = read0 then
X    readparameterlist(used,
X      restricted, stop)
X  else { id = readln0 }
X    begin
X      if token = leftparenthesis1
X        then
X          readparameterlist(used,
X            restricted, stop)
X        else
X          begin
X            newcontext(used);
X            include(used.targetvar,
X              inputfile)
X          end;
X      emit2(readln2, lineno)
X    end;
end;
X
{ WriteOption =
X    [ ":" Expression ] . }
X
procedure writeoption(
X  var option: integer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var typex: pointer;
begin
X  syntaxcheck([colon1] + stop);
X  if token = colon1 then
X    begin
X      expect(colon1,
X        expressiontokens + stop);
X      expression(typex, used,
X        restricted, stop);
X      checktypes(typex,
X        typeinteger);
X      option := ord(true)
X    end
X  else
X    begin
X      newcontext(used);
X      option := ord(false)
X    end
end;
X
{ WriteParameter =
X    Expression WriteOption
X      WriteOption . }
X
procedure writeparameter(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var option1, option2: integer;
X  typex: pointer;
X  used2: context;
X  stop2: tokens;
begin
X  stop2 := [colon1] + stop;
X  expression(typex, used,
X    restricted, stop2);
X  if typex = typereal then
X    begin
X      writeoption(option1, used2,
X        restricted, stop2);
X      addcontext(used, used2);
X      writeoption(option2, used2,
X        restricted, stop);
X      addcontext(used, used2);
X      emit4(writereal2, option1,
X        option2, lineno)
X    end
X  else
X    begin
X      writeoption(option1, used2,
X        restricted, stop);
X      addcontext(used, used2);
X      if typex = typechar then
X        emit3(write2, option1,
X          lineno)
X      else if typex = typeboolean
X        then
X          emit3(writebool2,
X            option1, lineno)
X      else if typex = typeinteger
X        then
X          emit3(writeint2, option1,
X            lineno)
X      else if typex = typestring
X        then
X          emit3(writestring2,
X            option1, lineno)
X      else typeerror(typex)
X    end;
X  include(used.targetvar,
X    outputfile);
X  pop(typelength(typex))
end;
X
{ WriteParameters =
X    WriteParameter
X      [ "," WriteParameter ]* . }
X
procedure writeparameters(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var used2: context; stop2: tokens;
begin
X  stop2 := [comma1] + stop;
X  writeparameter(used,
X    restricted, stop2);
X  while token = comma1 do
X    begin
X      expect(comma1,
X        expressiontokens + stop2);
X      writeparameter(used2,
X        restricted, stop2);
X      addcontext(used, used2)
X    end
end;
X
{ WriteParameterList =
X    "(" WriteParameters ")" . }
X
procedure writeparameterlist(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var stop2: tokens;
begin
X  stop2 :=
X    [rightparenthesis1] + stop;
X  expect(leftparenthesis1,
X    expressiontokens + stop2);
X  writeparameters(used,
X    restricted, stop2);
X  expect(rightparenthesis1, stop)
end;
X
{ WriteStatement =
X    "write" WriteParameterList |
X    "writeln"
X      [ WriteParameterList ] . }
X
procedure writestatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var id: integer;
begin
X  { token = (write procedure)
X      identifier }
X  expectid(id, [leftparenthesis1]
X    + stop);
X  if id = write0 then
X    writeparameterlist(used,
X      restricted, stop)
X  else { id = writeln0 }
X    begin
X      if token = leftparenthesis1
X        then
X          writeparameterlist(used,
X            restricted, stop)
X        else
X          begin
X            newcontext(used);
X            include(used.targetvar,
X              outputfile)
X          end;
X      emit2(writeln2, lineno)
X    end
end;
X
{ OpenParameter =
X    ChannelVariableAccess . }
X
procedure openparameter(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var typex: pointer;
begin
X  variableaccess(typex, used,
X    true, restricted, stop);
X  checktype(typex, channeltype);
X  emit2(open2, lineno);
X  pop(1)
end;
X
{ OpenParameters =
X    OpenParameter [ ","
X      OpenParameter ]* . }
X
procedure openparameters(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var used2: context; stop2: tokens;
begin
X  stop2 := [comma1] + stop;
X  openparameter(used,
X    restricted, stop2);
X  while token = comma1 do
X    begin
X      expect(comma1,
X        [identifier1] + stop2);
X      openparameter(used2,
X        restricted, stop2);
X      addcontext(used, used2)
X    end
end;
X
{ OpenStatement =
X    "open" "("
X      OpenParameters ")" . }
X
procedure openstatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var stop2, stop3: tokens;
begin
X  { token = (open procedure)
X      identifier }
X  stop2 := [rightparenthesis1]
X    + stop;
X  stop3 := [identifier1]
X    + stop2;
X  expect(identifier1,
X    [leftparenthesis1]
X      + stop3);
X  expect(leftparenthesis1,
X    stop3);
X  openparameters(used,
X    restricted, stop2);
X  expect(rightparenthesis1,
X    stop)
end;
X
{ InputVariableAccess =
X    VariableAccess . }
X
procedure inputvariableaccess(
X  chantype: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var vartype: pointer;
X  typeno: integer;
begin
X  variableaccess(
X    vartype, used, true,
X    restricted, stop);
X  checkmessage(chantype,
X    vartype, typeno);
X  emit4(receive2, typeno,
X    typelength(vartype),
X      lineno);
X  push(1); pop(2)
end;
X
{ InputVariableList =
X    InputVariableAccess
X      [ ","
X        InputVariableAccess ]*
X          . }
X
procedure inputvariablelist(
X  chantype: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var used2: context;
X  stop2: tokens;
begin
X  stop2 := [comma1] + stop;
X  inputvariableaccess(
X    chantype, used,
X    restricted, stop2);
X  while token = comma1 do
X    begin
X      expect(comma1,
X        [identifier1]
X          + stop2);
X      inputvariableaccess(
X        chantype, used2,
X        restricted, stop2);
X      addcontext(used,
X        used2)
X    end
end;
X
{ ReceiveParameters =
X    ChannelExpression ","
X      InputVariableList . }
X
procedure receiveparameters(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var chantype: pointer;
X  used2: context;
X  stop2: tokens;
begin
X  stop2 := [identifier1]
X    + stop;
X  expression(chantype,
X    used, restricted,
X    [comma1] + stop2);
X  emit2(checkio2, lineno);
X  expect(comma1, stop2);
X  inputvariablelist(chantype,
X    used2, restricted, stop);
X  addcontext(used, used2);
X  emit1(endio2);
X  pop(1)
end;
X
{ ReceiveStatement =
X    "receive" "("
X      ReceiveParameters ")" . }
X
procedure receivestatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var stop2, stop3: tokens;
begin
X  { token = (receive procedure)
X      identifier }
X  stop2 := [rightparenthesis1]
X    + stop;
X  stop3 := expressiontokens
X    + stop2;
X  expect(identifier1,
X    [leftparenthesis1]
X      + stop3);
X  expect(leftparenthesis1,
X    stop3);
X  receiveparameters(used,
X    restricted, stop2);
X  expect(rightparenthesis1,
X    stop)
end;
X
{ OutputExpression =
X    Expression . }
X
procedure outputexpression(
X  chantype: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var typeno, length: integer;
X  exprtype: pointer;
begin
X  expression(exprtype,
X    used, restricted, stop);
X  checkmessage(chantype,
X    exprtype, typeno);
X  length :=
X    typelength(exprtype);
X  emit4(send2, typeno,
X    length, lineno);
X  push(1); pop(length + 1)
end;
X
{ OutputExpressionList =
X    OutputExpression [ ","
X      OutputExpression ]*
X        . }
X
procedure
X  outputexpressionlist(
X    chantype: pointer;
X    var used: context;
X    restricted: boolean;
X    stop: tokens);
var used2: context;
X  stop2: tokens;
begin
X  stop2 := [comma1] + stop;
X  outputexpression(
X    chantype, used,
X    restricted, stop2);
X  while token = comma1 do
X    begin
X      expect(comma1,
X        expressiontokens
X          + stop2);
X      outputexpression(
X        chantype, used2,
X        restricted, stop2);
X      addcontext(used,
X        used2)
X    end
end;
X
{ SendParameters =
X    ChannelExpression ","
X      OutputExpressionList
X        . }
X
procedure sendparameters(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var chantype: pointer;
X  used2: context;
X  stop2: tokens;
begin
X  stop2 :=
X    expressiontokens
X      + stop;
X  expression(chantype,
X    used, restricted, 
X    [comma1] + stop2);
X  emit2(checkio2, lineno);
X  expect(comma1, stop2);
X  outputexpressionlist(
X    chantype, used2,
X    restricted, stop);
X  addcontext(used, used2);
X  emit1(endio2);
X  pop(1)
end;
X
{ SendStatement =
X    "send" "("
X      SendParameters ")"
X        . }
X
procedure sendstatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var stop2, stop3: tokens;
begin
X  { token =
X      (send procedure)
X        identifier }
X  stop2 :=
X    [rightparenthesis1]
X      + stop;
X  stop3 :=
X    expressiontokens
X      + stop2;
X  expect(identifier1,
X    [leftparenthesis1]
X      + stop3);
X  expect(leftparenthesis1,
X    stop3);
X  sendparameters(used,
X    restricted, stop2);
X  expect(rightparenthesis1,
X    stop)
end;
X
{ StandardProcedureStatement =
X    ReadStatement |
X    WriteStatement |
X    OpenStatement |
X    ReceiveStatement |
X    SendStatement . }
X
procedure
X  standardprocedurestatement(
X    var used: context;
X    restricted: boolean;
X    stop: tokens);
{ restrictions always satisfied }
begin
X  { token =
X      (standard procedure)
X        identifier }
X  if argument in
X    [read0, readln0] then
X      readstatement(used,
X        restricted, stop)
X  else if argument in
X    [write0, writeln0] then
X      writestatement(used,
X        restricted, stop)
X  else if argument = open0 then
X    openstatement(used,
X      restricted, stop)
X  else if argument = receive0 then
X    receivestatement(used,
X      restricted, stop)
X  else { argument = send0 }
X    sendstatement(used,
X      restricted, stop)
end;
X
{ ProcedureStatement =
X    ProcedureIdentifier
X      ActualParameterPart |
X    StandardProcedureStatement
X      . }
X
procedure procedurestatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var paramlength: integer;
X  proc: pointer;
begin
X  { token = (procedure)
X      identifier }
X  checkblock;
X  find(argument, proc);
X  if proc^.kind = standardproc
X    then
X      standardprocedurestatement(
X        used, restricted, stop)
X    else
X      begin
X        expect(identifier1,
X          [leftparenthesis1]
X            + stop);
X        actualparameterpart(
X          proc, paramlength,
X          used, restricted,
X          stop);
X        if within(proc) then
X          proc^.recursive :=
X            true;
X        emit3(proccall2,
X          blocklevel -
X            proc^.proclevel,
X          proc^.proclabel);
X        push(proc^.varlength);
X        pop(proc^.paramlength
X          + proc^.varlength)
X      end
end;
X
{ IfStatement =
X    "if" Expression
X      "then" Statement
X        [ "else" Statement ] . }
X
procedure ifstatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var label1, label2: integer;
X  exprtype: pointer;
X  used2: context;
X  stop2, stop3: tokens;
begin
X  stop2 :=
X    statementtokens + stop;
X  stop3 :=
X    [then1, else1] + stop2;
X  expect(if1, expressiontokens
X    + stop3);
X  expression(exprtype, used,
X    restricted, stop3);
X  checktypes(exprtype,
X    typeboolean);
X  expect(then1,
X    [else1] + stop2);
X  newlabel(label1);
X  emit2(do2, label1);
X  pop(1);
X  statement(used2,
X    restricted,
X    [else1] + stop);
X  addcontext(used, used2);
X  if token = else1 then
X    begin
X      expect(else1, stop2);
X      newlabel(label2);
X      emit2(goto2, label2);
X      emit2(defaddr2, label1);
X      statement(used2,
X        restricted, stop);
X      addcontext(used, used2);
X      emit2(defaddr2, label2)
X    end
X  else emit2(defaddr2, label1)
end;
X
{ WhileStatement =
X    "while" Expression
X      "do" Statement . }
X
procedure whilestatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var label1, label2: integer;
X  exprtype: pointer;
X  used2: context;
X  stop2, stop3: tokens;
begin
X  stop2 :=
X    statementtokens + stop;
X  stop3 := [do1] + stop2;
X  newlabel(label1);
X  emit2(defaddr2, label1);
X  expect(while1,
X    expressiontokens + stop3);
X  expression(exprtype, used,
X    restricted, stop3);
X  checktypes(exprtype,
X    typeboolean);
X  expect(do1, stop2);
X  newlabel(label2);
X  emit2(do2, label2);
X  pop(1);
X  statement(used2,
X    restricted, stop);
X  addcontext(used, used2);
X  emit2(goto2, label1);
X  emit2(defaddr2, label2)
end;
X
{ RepeatStatement =
X    "repeat" StatementSequence
X      "until" Expression . }
X
procedure repeatstatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var exprtype: pointer;
X  labelx: integer;
X  used2: context;
X  stop2, stop3: tokens;
begin
X  stop2 := expressiontokens
X    + stop;
X  stop3 := [until1] + stop2;
X  newlabel(labelx);
X  emit2(defaddr2, labelx);
X  expect(repeat1,
X    statementtokens + stop3);
X  statementsequence(used,
X    restricted, stop3);
X  expect(until1, stop2);
X  expression(exprtype, used2,
X    restricted, stop);
X  addcontext(used, used2);
X  checktypes(exprtype,
X    typeboolean);
X  emit2(do2, labelx);
X  pop(1)
end;
X
{ ForClause =
X    "for" EntireVariableAccess
X      ":=" Expression . }
X
procedure forclause(
X  var vartype: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var exprtype: pointer;
X  used2: context;
X  stop2, stop3: tokens;
begin
X  stop2 :=
X    expressiontokens + stop;
X  stop3 := [becomes1] + stop2;
X  expect(for1, stop3);
X  entirevariableaccess(
X    vartype, used, true,
X    stop3);
X  checktype(vartype, ordtype);
X  expect(becomes1, stop2);
X  expression(exprtype, used2,
X    restricted, stop);
X  addcontext(used, used2);
X  checktypes(vartype, exprtype);
X  emit1(for2); pop(1)
end;
X
{ UpClause =
X    "to" Expression
X      "do" Statement . }
X
procedure upclause(
X  vartype: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var label1, label2: integer;
X  exprtype: pointer;
X  used2: context;
X  stop2, stop3: tokens;
begin
X  stop2 :=
X    statementtokens + stop;
X  stop3 := [do1] + stop2;
X  newlabel(label1);
X  newlabel(label2);
X  expect(to1, expressiontokens
X    + stop3);
X  expression(exprtype, used,
X    restricted, stop3);
X  checktypes(vartype, exprtype);
X  expect(do1, stop2);
X  emit2(defaddr2, label1);
X  emit2(to2, label2);
X  statement(used2,
X    restricted, stop);
X  addcontext(used, used2);
X  emit2(endto2, label1);
X  emit2(defaddr2, label2);
X  pop(2)
end;
X
{ DownClause =
X    "downto" Expression
X      "do" Statement . }
X
procedure downclause(
X  vartype: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var label1, label2: integer;
X  exprtype: pointer;
X  used2: context;
X  stop2, stop3: tokens;
begin
X  stop2 :=
X    statementtokens + stop;
X  stop3 := [do1] + stop2;
X  newlabel(label1);
X  newlabel(label2);
X  expect(downto1,
X    expressiontokens + stop3);
X  expression(exprtype, used,
X    restricted, stop3);
X  checktypes(vartype, exprtype);
X  expect(do1, stop2);
X  emit2(defaddr2, label1);
X  emit2(downto2, label2);
X  statement(used2,
X    restricted, stop);
X  addcontext(used, used2);
X  emit2(enddown2, label1);
X  emit2(defaddr2, label2);
X  pop(2)
end;
X
{ ForStatement =
X    ForClause ForOption .
X  ForOption =
X    UpClause | DownClause . }
X
procedure forstatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var vartype: pointer;
X  used2: context;
begin
X  forclause(vartype,
X    used, restricted,
X    [downto1, to1] + stop);
X  if token = to1 then
X    upclause(vartype, used2,
X      restricted, stop)
X  else
X    downclause(vartype, used2,
X      restricted, stop);
X  addcontext(used, used2)
end;
X
{ CaseConstant =
X    OrdinalConstant . }
X
procedure caseconstant(
X  exprtype: pointer;
X  statlabel: integer;
X  var length: integer;
X  var table: casetable;
X  stop: tokens);
var value: integer;
X  found: boolean;
X  typex: pointer;
begin
X  ordinalconstant(value,
X    typex, stop);
X  checktypes(typex, exprtype);
X  if length < maxcase then
X    begin
X      insertcase(value,
X        statlabel, length,
X        table, found);
X      if found then
X          error(case3)
X    end
X  else halt(maxcase5)
end;
X
{ CaseConstantList =
X    CaseConstant
X      [ "," CaseConstant ]* . }
X
procedure caseconstantlist(
X  exprtype: pointer;
X  statlabel: integer;
X  var length: integer;
X  var table: casetable;
X  stop: tokens);
var stop2: tokens;
begin
X  stop2 := [comma1] + stop;
X  caseconstant(
X    exprtype, statlabel,
X    length, table, stop2);
X  while token = comma1 do
X    begin
X      expect(comma1,
X        constanttokens + stop2);
X      caseconstant(
X        exprtype, statlabel,
X        length, table, stop2)
X    end
end;
X
{ CaseListElement =
X    CaseConstantList
X      ":" Statement . }
X
procedure caselistelement(
X  exprtype: pointer;
X  endlabel: integer;
X  var length: integer;
X  var table: casetable;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var statlabel: integer;
X  stop2: tokens;
begin
X  newlabel(statlabel);
X  stop2 :=
X    statementtokens + stop;
X  caseconstantlist(
X    exprtype, statlabel,
X    length, table,
X    [colon1] + stop2);
X  expect(colon1, stop2);
X  emit2(defaddr2, statlabel);
X  statement(used, restricted,
X    stop);
X  emit2(goto2, endlabel)
end;
X
{ CaseList =
X    CaseListElement
X      [ ";" CaseListElement ]* .
X        [ ";" ] . }
X
procedure caselist(
X  exprtype: pointer;
X  endlabel: integer;
X  var length: integer;
X  var table: casetable;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var used2: context;
X  stop2: tokens;
begin
X  stop2 := [semicolon1] + stop;
X  length := 0;
X  caselistelement(
X    exprtype, endlabel,
X    length, table,
X    used, restricted,
X    stop2);
X  while token = semicolon1 do
X    begin
X      { use "stop" here }
X      expect(semicolon1,
X        constanttokens + stop);
X      if token in constanttokens
X        then
X          begin
X            caselistelement(
X              exprtype, endlabel,
X              length, table,
X              used2, restricted,
X              stop2);
X            addcontext(used,
X              used2)
X           end
X    end
end;
X
{ CaseStatement =
X    "case" Expression "of"
X      CaseList "end" . }
X
procedure casestatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var exprtype: pointer;
X  beginlabel, endlabel,
X  firstline, length:
X    integer;
X  table: casetable;
X  used2: context;
X  stop2, stop3: tokens;
begin
X  stop2 := [end1] + stop;
X  stop3 :=
X    constanttokens + stop2;
X  newlabel(beginlabel);
X  newlabel(endlabel);
X  firstline := lineno;
X  expect(case1, [of1] +
X    expressiontokens + stop3);
X  expression(exprtype, used,
X    restricted, [of1] + stop3);
X  checktype(exprtype, ordtype);
X  expect(of1, stop3);
X  emit2(goto2, beginlabel);
X  pop(1);
X  caselist(exprtype, endlabel,
X    length, table, used2,
X    restricted, stop2);
X  addcontext(used, used2);
X  emit2(defaddr2, beginlabel);
X  emitcase(firstline, length,
X    table);
X  emit2(defaddr2, endlabel);
X  expect(end1, stop)
end;
X
{ StatementSequence =
X    Statement
X      [ ";" Statement ]* . }
X
procedure statementsequence{
X  var used: context;
X  restricted: boolean;
X  stop: tokens};
var used2: context;
X  stop2: tokens;
begin
X  stop2 := [semicolon1] + stop;
X  statement(used,
X    restricted, stop2);
X  while token = semicolon1 do
X    begin
X      expect(semicolon1,
X        statementtokens + stop2);
X      statement(used2,
X        restricted, stop2);
X      addcontext(used, used2)
X    end
end;
X
{ CompoundStatement =
X    "begin" StatementSequence
X       "end" . }
X
procedure compoundstatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var stop2: tokens;
begin
X  stop2 := [end1] + stop;
X  expect(begin1,
X    statementtokens + stop2);
X  statementsequence(used,
X    restricted, stop2);
X  expect(end1, stop)
end;
X
{ ProcessStatement =
X    StatementSequence . }
X
procedure processstatement(
X    exitlabel: integer;
X    var used: context;
X    restricted: boolean;
X    stop: tokens);
var templabel, endlabel:
X  integer;
begin
X  newblock(block[blocklevel]
X    .heading);
X  newlabel(templabel);
X  newlabel(endlabel);
X  emit4(process2, templabel,
X    endlabel, lineno);
X  statementsequence(used,
X    restricted, stop);
X  emit3(defarg2, templabel,
X    block[blocklevel].
X      maxtemp);
X  emit3(endprocess2,
X    exitlabel, lineno);
X  emit2(defaddr2, endlabel);
X  endblock
end;
X
{ ProcessStatementList =
X    ProcessStatement
X      [ "|" ProcessStatement ]*
X        . }
X
procedure processstatementlist(
X  exitlabel: integer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var used2: context;
X  stop2: tokens;
begin
X  stop2 := [bar1] + stop;
X  processstatement(
X    exitlabel, used,
X    restricted, stop2);
X  while token = bar1 do
X    begin
X      expect(bar1,
X        statementtokens + stop2);
X      processstatement(
X        exitlabel, used2,
X        restricted, stop2);
X      if restricted and not
X        (disjoint(
X           used.targetvar,
X           used2.targetvar)
X        and
X         disjoint(
X           used.targetvar,
X           used2.exprvar)
X        and
X         disjoint(
X           used.exprvar,
X           used2.targetvar))
X        then error(parallel3);
X      addcontext(used, used2)
X    end
end;
X
{ ParallelStatement =
X    "parallel"
X      ProcessStatementList
X        "end" . }
X
procedure parallelstatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var exitlabel: integer;
X  stop2: tokens;
begin
X  stop2 := [end1] + stop;
X  emit1(parallel2);
X  push(1);
X  expect(parallel1,
X    statementtokens + stop2);
X  newlabel(exitlabel);
X  processstatementlist(
X    exitlabel, used,
X    restricted, stop2);
X  expect(end1, stop);
X  emit2(endparallel2, lineno);
X  emit2(defaddr2, exitlabel);
X  pop(1)
end;
X
{ ProcessIndexRange =
X    Expression "to"
X      Expression . }
X
procedure processindexrange(
X  var typex: pointer;
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var type2: pointer;
X  used2: context;
X  stop2: tokens;
begin
X  stop2 := expressiontokens
X    + stop;
X  expression(typex, used,
X    restricted,
X    [to1] + stop2);
X  expect(to1, stop2);
X  expression(type2, used2,
X    restricted, stop);
X  addcontext(used, used2);
X  checktype(typex, ordtype);
X  checktypes(typex, type2)
end;
X
{ IndexVariableDeclaration =
X    VariableIdentifier ":="
X      ProcessIndexRange . }
X
procedure
X  indexvariabledeclaration(
X    var used: context;
X    restricted: boolean;
X    stop: tokens);
var id: integer; typex,
X  varx: pointer;
X  stop2: tokens;
begin
X  stop2 := expressiontokens
X    + stop;
X  expectid(id, [becomes1]
X    + stop2);
X  expect(becomes1, stop2);
X  processindexrange(typex,
X    used, restricted, stop);
X  newblock(block[blocklevel]
X    .heading);
X  declare(id, variable, varx);
X  varx^.vartype := typex;
X  variableaddressing(1, varx);
X  include(used.exprvar, varx)
end;
X
{ ForallStatement =
X    "forall"
X      IndexVariableDeclaration
X        "do" Statement . }
X
procedure forallstatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var endlabel, templabel:
X  integer; used2: context;
X  stop2, stop3: tokens;
begin
X  stop2 := statementtokens
X    + stop;
X  stop3 := [do1] + stop2;
X  expect(forall1,
X    [identifier1] + stop3);
X  indexvariabledeclaration(
X    used, restricted, stop3);
X  expect(do1, stop2);
X  newlabel(templabel);
X  newlabel(endlabel);
X  emit4(forall2, templabel,
X    endlabel, lineno);
X  statement(used2, restricted,
X    stop);
X  if restricted and not
X    empty(used2.targetvar)
X      then error(forall3);
X  addcontext(used, used2);
X  emit3(defarg2, templabel,
X    block[blocklevel].
X      maxtemp);
X  emit2(endall2, lineno);
X  emit2(defaddr2, endlabel);
X  endblock;
X  pop(2)
end;
X
{ UnrestrictedStatement =
X    SicClause Statement .
X  SicClause =
X    "[" "sic" "]" . }
X
procedure
X  unrestrictedstatement(
X    var used: context;
X    stop: tokens);
const restricted = false;
var stop2, stop3: tokens;
begin
X  stop2 := statementtokens
X    + stop;
X  stop3 := [rightbracket1]
X    + stop2;
X  expect(leftbracket1,
X    [sic1] + stop3);
X  expect(sic1, stop3);
X  expect(rightbracket1, stop2);
X  statement(used, restricted,
X    stop)
end;
X
{ AssumeStatement =
X    "assume" Expression . }
X
procedure assumestatement(
X  var used: context;
X  restricted: boolean;
X  stop: tokens);
var typex: pointer;
begin
X  expect(assume1,
X    expressiontokens + stop);
X  expression(typex, used,
X    restricted, stop);
X  checktypes(typex,
X    typeboolean);
X  emit2(assume2, lineno);
X  pop(1)
end;
X
{ Statement =
X    AssignmentStatement |
X    ProcedureStatement |
X    IfStatement |
X    WhileStatement |
X    RepeatStatement |
X    ForStatement |
X    CaseStatement |
X    CompoundStatement |
X    ParallelStatement |
X    ForallStatement |
X    UnrestrictedStatement |
X    AssumeStatement |
X    EmptyStatement .
X  EmptyStatement = . }
X
procedure statement{
X  var used: context;
X  restricted: boolean;
X  stop: tokens};
var object: pointer;
begin
X  if token = identifier1 then
X    begin
X      find(argument, object);
X      if object^.kind in leftparts
X        then
X          assignmentstatement(
X            used, restricted,
X            stop)
X      else if object^.kind in
X        procedures then
X          procedurestatement(
X            used, restricted,
X            stop)
X        else
X          begin
X            newcontext(used);
X            kinderror(object);
X            expect(identifier1,
X              stop)
X          end
X    end
X  else if token = if1 then
X    ifstatement(used,
X      restricted, stop)
X  else if token = while1 then
X    whilestatement(used,
X      restricted, stop)
X  else if token = repeat1 then
X    repeatstatement(used,
X      restricted, stop)
X  else if token = for1 then
X    forstatement(used,
X      restricted, stop)
X  else if token = case1 then
X    casestatement(used,
X      restricted, stop)
X  else if token = begin1 then
X    compoundstatement(used,
X      restricted, stop)
X  else if token = parallel1 then
X    parallelstatement(used,
X      restricted, stop)
X  else if token = forall1 then
X    forallstatement(used,
X      restricted, stop)
X  else if token = leftbracket1
X  then
X    unrestrictedstatement(used,
X      stop)
X  else if token = assume1 then
X    assumestatement(used,
X      restricted, stop)
X  else { empty statement }
X    begin
X      newcontext(used);
X      syntaxcheck(stop)
X    end
end;
X
{ StatementPart =
X    CompoundStatement . }
X
procedure statementpart{
X  var templength: integer;
X  var used: context;
X  stop: tokens};
begin
X  { restricted is a
X    global constant }
X  compoundstatement(used,
X    restricted, stop);
X  templength :=
X    block[blocklevel].maxtemp
end;
X
{ ProgramParameters =
X    ParameterIdentifier [ ","
X      ParameterIdentifier ]* . }
X
procedure programparameters(
X  stop: tokens);
var stop2: tokens;
begin
X  stop2 := [comma1] + stop;
X  expect(identifier1, stop2);
X  while token = comma1 do
X    begin
X      expect(comma1,
X        [identifier1] + stop2);
X      expect(identifier1, stop2)
X  end
end;
X
{ ProgramParameterPart =
X   [ "(" ProgramParameters ")" ]
X     . }
X
procedure programparameterpart(
X  stop: tokens);
var stop2: tokens;
begin
X  syntaxcheck([leftparenthesis1]
X    + stop);
X  if token = leftparenthesis1 then
X    begin
X      stop2 := [rightparenthesis1]
X        + stop;
X      expect(leftparenthesis1,
X        [identifier1] + stop2);
X      programparameters(stop2);
X      expect(rightparenthesis1,
X        stop)
X    end
end;
X
{ ProgramHeading =
X   "program" ProgramIdentifier
X     ProgramParameterPart . }
X
procedure programheading(
X  stop: tokens);
var stop2: tokens;
begin
X  stop2 :=
X    [leftparenthesis1] + stop;
X  expect(program1,
X    [identifier1] + stop2);
X  expect(identifier1, stop2);
X  programparameterpart(stop)
end;
X
{ Program =
X    ProgramHeading ";"
X      Block "." . }
X
procedure programx(stop: tokens);
var used: context;
X  varlabel, templabel,
X  beginlabel, varlength,
X  templength: integer;
X  stop2, stop3, stop4: tokens;
begin
X  stop2 := [period1] + stop;
X  stop3 := [begin1] + stop2;
X  stop4 := declarationtokens
X    + stop3;
X  programheading([semicolon1]
X    + stop4);
X  newlabel(varlabel);
X  newlabel(templabel);
X  newlabel(beginlabel);
X  emit5(program2,
X    varlabel, templabel,
X    beginlabel, lineno);
X  expect(semicolon1, stop4);
X  newblock(nil);
X  declarationpart(varlength,
X    stop3);
X  emit3(defarg2, varlabel,
X    varlength);
X  emit2(defaddr2, beginlabel);
X  statementpart(templength,
X    used, stop2);
X  emit3(defarg2, templabel,
X    templength);
X  emit1(endprog2);
X  endblock;
X  expect(period1, stop)
end;
X
begin
X  initialize;
X  standardblock;
X  nexttoken;
X  programx([endtext1])
end;
SHAR_EOF
  $shar_touch -am 1029021698 'parse.p' &&
  chmod 0600 'parse.p' ||
  $echo 'restore of' 'parse.p' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'parse.p:' 'MD5 check failed'
3dc973b70efc80952891de0b51ca0e6a  parse.p
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'parse.p'`"
    test 92663 -eq "$shar_count" ||
    $echo 'parse.p:' 'original size' '92663,' 'current size' "$shar_count!"
  fi
fi
# ============= assemble.p ==============
if test -f 'assemble.p' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'assemble.p' '(file already exists)'
else
  $echo 'x -' extracting 'assemble.p' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'assemble.p' &&
{         SUPERPASCAL COMPILER
X                ASSEMBLER
X             20 August 1993
X  Copyright (c) 1993 Per Brinch Hansen }
X
procedure assemble(
X  optimizing: boolean;
X  procedure get(var value: integer);
X  procedure put(value: integer);
X  procedure getreal(var value: real);
X  procedure putreal(value: real);
X  procedure getstring(
X    var length: integer;
X    var value: string);
X  procedure putstring(
X    length: integer;
X    value: string);
X  procedure getcase(
X    var lineno, length: integer;
X    var table: casetable);
X  procedure putcase(
X    lineno, length: integer;
X    table: casetable);
X  procedure rerun;
X  procedure halt(kind: phrase));
type
X  operations = set of minoperation
X    ..maxoperation;
X  assemblytable =
X    array [1..maxlabel] of integer;
var
X  noarguments, oneargument,
X  twoarguments, threearguments,
X  fourarguments, fivearguments,
X  jumps: operations;
X  blockno, address, op, arg1, arg2,
X  arg3, arg4, arg5: integer;
X  realarg: real;
X  stringarg: string;
X  casearg: casetable;
X  table: assemblytable;
X
procedure nextinstruction;
begin
X  get(op);
X  if op in noarguments then
X    { skip }
X  else if op in oneargument then
X    get(arg1)
X  else if op in twoarguments then
X    begin
X      get(arg1); get(arg2)
X    end
X  else if op in threearguments then
X    begin
X      get(arg1); get(arg2);
X      get(arg3)
X    end
X  else if op in fourarguments then
X    begin
X      get(arg1); get(arg2);
X      get(arg3); get(arg4)
X    end
X  else if op in fivearguments then
X    begin
X      get(arg1); get(arg2);
X      get(arg3); get(arg4);
X      get(arg5)
X    end
X  else if op = realconst2 then
X    getreal(realarg)
X  else if op = stringconst2 then
X    getstring(arg1, stringarg)
X  else { op = caseconst2 }
X    getcase(arg1, arg2,
X      casearg)
end;
X
procedure emit1(op: integer);
begin
X  put(op);
X  address := address + 1
end;
X
procedure emit2(
X  op, arg: integer);
begin
X  put(op); put(arg);
X  address := address + 2
end;
X
procedure emit3(
X  op, arg1, arg2: integer);
begin
X  put(op); put(arg1);
X  put(arg2);
X  address := address + 3
end;
X
procedure emit4(
X  op, arg1, arg2,
X  arg3: integer);
begin
X  put(op); put(arg1);
X  put(arg2); put(arg3);
X  address := address + 4
end;
X
procedure emit5(
X  op, arg1, arg2, arg3,
X  arg4: integer);
begin
X  put(op); put(arg1);
X  put(arg2); put(arg3);  
X  put(arg4);
X  address := address + 5
end;
X
procedure emit6(
X  op, arg1, arg2, arg3,
X  arg4, arg5: integer);
begin
X  put(op); put(arg1);
X  put(arg2); put(arg3);
X  put(arg4); put(arg5);
X  address := address + 6
end;
X
procedure emit7(
X  op, arg1, arg2, arg3, arg4,
X  arg5, arg6: integer);
begin
X  put(op); put(arg1);
X  put(arg2); put(arg3);
X  put(arg4); put(arg5);
X  put(arg6);
X  address := address + 7
end;
X
procedure emitreal(
X  value: real);
begin
X  put(realconst2);
X  putreal(value);
X  address := address + 3
end;
X
procedure emitstring(
X  length: integer;
X  value: string);
begin
X  put(stringconst2);
X  putstring(length, value);
X  address :=
X    address + length + 2
end;
X
procedure emitcase(
X  lineno, length: integer;
X  table: casetable);
begin
X  put(case2);
X  putcase(lineno, length,
X    table);
X  address :=
X    address + 2*length + 3
end;
X
procedure newblock;
begin
X  if blockno = maxblock then
X    halt(maxblock5);
X  blockno := blockno + 1
end;
X
function optimize(condition:
X  boolean): boolean;
begin
X  optimize :=
X    optimizing and condition
end;
X
function templength(labelno:
X  integer): integer;
begin
X  { include block link
X    (or process state)
X    of length 4 (or 3) }
X  templength :=
X    table[labelno] + 4
end;
X
function jumpdispl(labelno:
X  integer): integer;
begin
X  jumpdispl :=
X    table[labelno] - address
end;
X
procedure assign(
X  length: integer);
begin
X  if optimize(length = 1)
X    then emit1(ordassign2)
X  else if optimize(length = 2)
X    then emit1(realassign2)
X  else emit2(assign2, length);
X  nextinstruction
end;
X
procedure casex(
X  lineno, length: integer;
X  table: casetable);
var i: integer;
begin
X  for i := 1 to length do
X    table[i].index :=
X      jumpdispl(
X        table[i].index);
X  emitcase(lineno, length,
X    table);
X  nextinstruction
end;
X
procedure defaddr(labelno:
X  integer);
begin
X  table[labelno] := address;
X  nextinstruction
end;
X
procedure defarg(labelno,
X  value: integer);
begin
X  table[labelno] := value;
X  nextinstruction
end;
X
procedure endprocess(exitlabel,
X  lineno: integer);
begin
X  emit3(endprocess2,
X    jumpdispl(exitlabel),
X    lineno);
X  nextinstruction
end;
X
procedure field(displ: integer);
begin
X  if optimize(displ = 0)
X    then { empty }
X    else emit2(field2, displ);
X  nextinstruction
end;
X
procedure forall(templabel,
X  endlabel, lineno: integer);
begin
X  newblock;
X  emit5(forall2, blockno,
X    templength(templabel),
X    jumpdispl(endlabel),
X    lineno);
X  nextinstruction
end;
X
procedure jump(op, labelno:
X  integer);
begin
X  { op in [do2, downto2,
X      enddown2, endto2,
X        goto2, to2] }
X  emit2(op,
X    jumpdispl(labelno));
X  nextinstruction
end;
X
procedure proccall(level,
X  labelno: integer);
var displ: integer;
begin
X  displ := jumpdispl(labelno);
X  if optimize(level = 1) then
X    emit2(globalcall2, displ)
X  else
X    emit3(proccall2, level,
X      displ);
X  nextinstruction
end;
X
procedure procedur(paramlength,
X  varlabel, templabel,
X  beginlabel, lineno: integer);
begin
X  newblock;
X  emit7(procedure2, blockno,
X    paramlength,
X    table[varlabel],
X    templength(templabel),
X    jumpdispl(beginlabel),
X    lineno);
X  nextinstruction
end;
X
procedure process(templabel,
X  endlabel, lineno: integer);
begin
X  newblock;
X  emit5(process2, blockno,
X    templength(templabel),
X    jumpdispl(endlabel),
X    lineno);
X  nextinstruction
end;
X
procedure programx(varlabel,
X  templabel, beginlabel,
X  lineno: integer);
begin
X  newblock;
X  emit6(program2, blockno,
X    table[varlabel],
X    templength(templabel),
X    jumpdispl(beginlabel),
X    lineno);
X  nextinstruction
end;
X
procedure value(length: integer);
begin
X  if optimize(length = 1)
X    then emit1(ordvalue2)
X  else if optimize(length = 2)
X    then emit1(realvalue2)
X  else emit2(value2, length);
X  nextinstruction
end;
X
procedure variable(level, displ:
X  integer);
begin
X  if displ >= 0 then
X    { include block link
X      of length 4 }
X    displ := displ + 4;
X  nextinstruction;
X  while optimize(op = field2) do
X    begin
X      displ := displ + arg1;
X      nextinstruction
X    end;
X  if optimize(level = 0) then
X    if (op = value2) and
X      (arg1 = 1) then
X        begin
X          emit2(localvalue2,
X            displ);
X          nextinstruction
X        end
X    else if (op = value2) and
X      (arg1 = 2) then
X        begin
X          emit2(localreal2,
X            displ);
X          nextinstruction
X        end
X    else emit2(localvar2, displ)
X  else if optimize(level = 1) then
X    if (op = value2) and
X      (arg1 = 1) then
X        begin
X          emit2(globalvalue2,
X            displ);
X          nextinstruction
X        end
X    else emit2(globalvar2, displ)
X  else
X    emit3(variable2, level, displ)
end;
X
procedure copyinstruction;
begin
X  if op in noarguments
X    then emit1(op)
X  else if op in oneargument
X    then emit2(op, arg1)
X  else if op in twoarguments
X    then emit3(op, arg1, arg2)
X  else if op in threearguments
X    then
X      emit4(op, arg1, arg2,
X        arg3)
X  else if op in fourarguments
X    then
X      emit5(op, arg1, arg2,
X        arg3, arg4)
X  else if op in fivearguments
X    then
X      emit6(op, arg1, arg2,
X        arg3, arg4, arg5)
X  else if op = realconst2
X    then emitreal(realarg)
X  else { op = stringconst2 }
X    emitstring(arg1,
X      stringarg);
X  nextinstruction
end;
X
procedure assemble;
begin
X  blockno := 0;
X  address := 0;
X  nextinstruction;
X  while op <> endprog2 do
X    if op = assign2 then
X      assign(arg1)
X    else if op = case2 then
X      casex(arg1, arg2, casearg)
X    else if op = defaddr2 then
X      defaddr(arg1) 
X    else if op = defarg2 then
X      defarg(arg1, arg2)
X    else if op = endprocess2 then
X      endprocess(arg1, arg2)
X    else if op = field2 then
X      field(arg1)
X    else if op = forall2 then
X      forall(arg1, arg2, arg3)
X    else if op in jumps then
X      jump(op, arg1)
X    else if op = proccall2 then
X      proccall(arg1, arg2)
X    else if op = procedure2 then
X      procedur(arg1, arg2, arg3,
X        arg4, arg5)
X    else if op = process2 then
X      process(arg1, arg2, arg3)
X    else if op = program2 then
X      programx(arg1, arg2, arg3,
X        arg4)
X    else if op = value2 then
X      value(arg1)
X    else if op = variable2 then
X      variable(arg1, arg2)
X    else copyinstruction;
X  emit1(endprog2)
end;
X
procedure initialize;
var labelno: integer;
begin
X  noarguments :=
X    [and2, endio2, endproc2,
X    endprog2, eqord2, eqreal2,
X    eqstring2, float2,
X    floatleft2, for2, grord2,
X    grreal2, grstring2, lsord2,
X    lsreal2, lsstring2, neord2,
X    nereal2, nestring2, ngord2,
X    ngreal2, ngstring2, nlord2,
X    nlreal2, nlstring2, not2,
X    odd2, or2, parallel2];
X  oneargument :=
X    [abs2, absint2, add2,
X    addreal2, arctan2, assign2,
X    assume2, checkio2, chr2,
X    cos2, divide2, divreal2,
X    do2, downto2, endall2,
X    enddown2, endparallel2,
X    endto2, eof2, eoln2,
X    equal2, exp2, field2,
X    goto2, ln2, minus2,
X    minusreal2, modulo2, multiply2,
X    multreal2, notequal2, open2,
X    ordconst2, read2, readint2,
X    readln2, readreal2, result2,
X    round2, sin2, sqr2,
X    sqrint2, sqrt2, subreal2,
X    subtract2, to2, trunc2,
X    value2, writeln2, defaddr2];
X  twoarguments :=
X    [endprocess2, pred2,
X    proccall2, succ2, variable2,
X    varparam2, write2,
X    writebool2, writeint2,
X    writestring2, defarg2];
X  threearguments :=
X    [forall2, process2,
X    receive2, send2,
X    writereal2];
X  fourarguments :=
X    [index2, program2];
X  fivearguments :=
X    [procedure2];
X  jumps :=
X    [do2, downto2, enddown2,
X    endto2, goto2, to2]; 
X  for labelno := 1 to maxlabel
X    do table[labelno] := 0
end;
X
begin
X  initialize; assemble;
X  rerun; assemble
end;
SHAR_EOF
  $shar_touch -am 1029021698 'assemble.p' &&
  chmod 0600 'assemble.p' ||
  $echo 'restore of' 'assemble.p' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'assemble.p:' 'MD5 check failed'
679647627bab5fae3d6a69795b77f592  assemble.p
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'assemble.p'`"
    test 9910 -eq "$shar_count" ||
    $echo 'assemble.p:' 'original size' '9910,' 'current size' "$shar_count!"
  fi
fi
# ============= compile.p ==============
if test -f 'compile.p' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'compile.p' '(file already exists)'
else
  $echo 'x -' extracting 'compile.p' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'compile.p' &&
{         SUPERPASCAL COMPILER
X              MAIN PROGRAM
X             20 August 1993
X  Copyright (c) 1993 Per Brinch Hansen }
X
program main(input, output);
#include "common.p"
#include "scan.p"
#include "parse.p"
#include "assemble.p"
X
procedure compile;
label 1 { exit };
type
X  table =
X    array [1..maxbuf] of
X      integer;
X  buffer =
X    record
X      contents: table;
X      length: integer
X    end;
var
X  sourcename, codename: phrase;
X  errors, source: text;
X  code: binary;
X  inpbuf, outbuf: buffer;
X  compiled, endline, lineok,
X  optimizing, testing: boolean;
X  lineno, pass: integer;
X
procedure error(kind: phrase);
var n: integer;
begin
X  if lineok then
X    begin
X      if compiled then
X        begin
X          compiled := false;
X          writeln
X        end;
X      n := phraselength(kind);
X      writeln(errors,
X        'line ', lineno:4, sp,
X        kind:n);
X      writeln(
X        'line ', lineno:4, sp,
X        kind:n);
X      lineok := false
X    end
end;
X
procedure halt(kind: phrase);
var n: integer;
begin
X  if compiled then
X    begin
X      compiled := false;
X      writeln
X    end;
X  n := phraselength(kind);
X  writeln(errors,
X    'line ', lineno:4, sp,
X    kind:n);
X  writeln(
X    'line ', lineno:4, sp,
X    kind:n);
X  goto 1
end;
X
procedure newline(no: integer);
begin
X  lineno := no;
X  lineok := true
end;
X
procedure accept(var ch: char);
begin
X  if eof(source) then
X    begin
X      lineno := lineno + 1;
X      ch := chr(etx)
X    end
X  else
X    begin
X      if endline then
X        begin
X          lineno := lineno + 1;
X          endline := false;
X          lineok := true;
X          if testing then
X            write(lineno:4, sp)
X        end;
X      if eoln(source) then
X        begin
X          readln(source);
X          ch := chr(nl);
X          endline := true;
X          if testing then
X            writeln
X        end
X      else
X        begin
X          read(source, ch);
X          if testing then
X            write(ch)
X        end
X    end
end;
X
procedure put(value: integer);
begin
X  if outbuf.length = maxbuf
X    then halt(maxbuf5);
X  outbuf.length :=
X    outbuf.length + 1;
X  outbuf.contents[
X    outbuf.length] := value
end;
X
procedure get(
X  var value: integer);
begin
X  inpbuf.length :=
X    inpbuf.length + 1;
X  value := inpbuf.contents[
X    inpbuf.length];
X  if testing then
X    writeln(pass:1, sp,
X      value:12)
end;
X
procedure getreal(
X  var value: real);
var dual: dualreal;
begin
X  dual.split := true;
X  get(dual.b);
X  get(dual.c);
X  dual.split := false;
X  value := dual.a
end;
X
procedure putreal(value: real);
var dual: dualreal;
begin
X  dual.split := false;
X  dual.a := value;
X  dual.split := true;
X  put(dual.b);
X  put(dual.c)
end;
X
procedure getstring(
X  var length: integer;
X  var value: string);
var c, i: integer;
begin
X  get(length);
X  for i := 1 to length do
X    begin
X      get(c);
X      value[i] := chr(c)
X    end;
X  for i := length + 1
X    to maxstring do
X      value[i] := chr(null)
end;
X
procedure putstring(
X  length: integer;
X  value: string);
var i: integer;
begin
X  put(length);
X  for i := 1 to length do
X    put(ord(value[i]))
end;
X
procedure getcase(
X  var lineno, length: integer;
X  var table: casetable);
var i: integer;
begin
X  get(lineno); get(length);
X  for i := 1 to length do
X    begin
X      get(table[i].value);
X      get(table[i].index)
X    end
end;
X
procedure putcase(
X  lineno, length: integer;
X  table: casetable);
var i: integer;
begin
X  put(lineno); put(length);
X  for i := 1 to length do
X    begin
X      put(table[i].value);
X      put(table[i].index)
X    end
end;
X
function checksum: integer;
const n = 8191;
var i, sum, x: integer;
begin
X  sum := 0;
X  for i := 1 to outbuf.length do
X    begin
X      x := outbuf.contents[i];
X      sum :=
X       (sum + x mod n) mod n
X    end;
X  checksum := sum
end;
X
procedure testoutput(
X  kind: phrase);
const
X  max = 5 { symbols/line };
var i, n: integer;
X  log: text;
begin
X  if testing then
X    begin
X      { nonstandard rewrite }
X      rewrite(log, kind);
X      writephrase(log,
X        sourcename);
X      write(log, sp);
X      writephrase(log, kind);
X      writeln(log);
X      n := outbuf.length;
X      for i := 1 to
X        outbuf.length do
X          begin
X            if i mod max = 1
X              then
X                writeln(log);
X            write(log, outbuf.
X              contents[i]:12)
X          end;
X      writeln(log);
X      writeln(log);
X      writeln(log,
X         'check sum = ',
X        checksum:4);
X      writeln
X    end
end;
X
procedure codeoutput;
var i: integer;
begin
X  { nonstandard rewrite }
X  rewrite(code, codename);
X  for i := 1 to outbuf.length do
X    write(code,
X      outbuf.contents[i])
end;
X
procedure rerun;
begin
X  inpbuf.length := 0;
X  outbuf.length := 0
end;
X
procedure firstpass;
begin
X  write('    source = ');
X  readphrase(sourcename);
X  write('    code = ');
X  readphrase(codename);
X  if testoptions then
X    begin
X      write(
X        '    test output? ');
X      readboolean(testing);
X      write(
X        '    optimize? ');
X      readboolean(optimizing);
X      if testing then writeln
X    end
X  else
X    begin
X      testing := false;
X      optimizing := true
X    end;
X  compiled := true;
X  lineno := 0;
X  { nonstandard rewrite }
X  rewrite(errors, errorfile);
X  writephrase(errors,
X    sourcename);
X  writeln(errors);
X  writeln(errors);
X  if sourcename = codename
X    then halt(fileconflict);
X  { nonstandard reset }
X  reset(source, sourcename);
X  pass := 1;
X  outbuf.length := 0;
X  endline := true;
X  lineno := 0
end;
X
procedure nextpass;
begin
X  pass := pass + 1;
X  { swap buffers }
X  inpbuf := outbuf;
X  inpbuf.length := 0;
X  outbuf.length := 0
end;
X
procedure exit;
begin
X  if compiled then
X    writeln(errors,
X      'no errors found')
X  else writeln
end;
X
begin
X  firstpass;
X  scan(lineno, accept, put,
X    putreal, putstring,
X    error, halt);
X  if compiled then
X    begin
X      testoutput(scanned);
X      nextpass;
X      parse(newline, get, put,
X        getreal, putreal,
X        getstring, putstring,
X        putcase, error, halt);
X      if compiled then
X        begin
X          testoutput(parsed);
X          nextpass;
X          assemble(optimizing,
X            get, put, getreal,
X            putreal, getstring,
X            putstring, getcase,
X            putcase, rerun,
X            halt);
X          if compiled then
X            begin
X              testoutput(
X                assembled);
X              codeoutput
X            end
X        end
X    end;
X  1: exit
end { compile };
X
begin compile end.
SHAR_EOF
  $shar_touch -am 1029021698 'compile.p' &&
  chmod 0600 'compile.p' ||
  $echo 'restore of' 'compile.p' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'compile.p:' 'MD5 check failed'
75bed2034c57b6e666533af6d498d0b2  compile.p
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'compile.p'`"
    test 6459 -eq "$shar_count" ||
    $echo 'compile.p:' 'original size' '6459,' 'current size' "$shar_count!"
  fi
fi
# ============= interpret.p ==============
if test -f 'interpret.p' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'interpret.p' '(file already exists)'
else
  $echo 'x -' extracting 'interpret.p' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'interpret.p' &&
{        SUPERPASCAL INTERPRETER
X             20 August 1993
X  Copyright (c) 1993 Per Brinch Hansen }
X
program interpret(input, output);
#include "common.p"
X
procedure run(
X  var codefile: binary;
X  var inpfile, outfile: text);
const minaddr = 1;
type
X  store =
X    array [minaddr..maxaddr] of
X      integer;
X  blocktable =
X    array [1..maxblock] of integer;
X  channeltable =
X    array [1..maxchan] of integer;
var
X  { permanent variables }
X  b, cmax, p, ready, s,
X  stackbottom, t: integer;
X  running: boolean;
X  st: store;
X  free: blocktable;
X  open: channeltable;
X
X  { temporary variables }
X  bi, blockno, c, i,
X  j, k, length, level,
X  lineno, lower, m, n,
X  pi, si, templength,
X  typeno, typeno2, upper,
X  width, x, y: integer;
X  dx, dy: dualreal;
X  sx: string;
X  cx: char;
X  
{ Local procedures in run }
X
procedure error(lineno: integer; 
X  kind: phrase);
begin
X  writeln('line ', lineno:4, sp,
X    kind:phraselength(kind));
X  running := false
end;
X
procedure rangeerror(
X  lineno: integer);
begin
X  error(lineno, range4)
end;
X
procedure memorylimit(
X  lineno: integer);
begin
X  error(lineno, maxaddr5)
end;
X
procedure load(
X  var codefile: binary);
var i: integer;
begin
X  i := minaddr;
X  while not eof(codefile)
X    and (i < maxaddr) do 
X      begin
X        read(codefile, st[i]);
X        i := i + 1
X      end;
X  if not eof(codefile)
X    then memorylimit(1)
X    else stackbottom := i
end;
X
procedure activate(
X  bvalue, svalue, pvalue:
X  integer);
begin
X  svalue := svalue + 3;
X  st[svalue - 2] := pvalue;
X  st[svalue - 1] := bvalue;
X  st[svalue] := ready;
X  ready := svalue
end;
X
procedure select(
X  lineno: integer);
begin
X  if ready = 0 then
X    error(lineno, deadlock4)
X  else
X    begin
X      s := ready;
X      ready := st[s];
X      b := st[s - 1];
X      p := st[s - 2];
X      s := s - 3
X    end
end;
X
procedure popstring(
X  var value: string);
var i: integer;
begin
X  s := s - maxstring;
X  for i := 1 to maxstring do
X    value[i] := chr(st[s + i])
end;
X
begin
X  load(codefile);
X  p := minaddr;
X  running := true;
X  while running do
X    case st[p] of
X
X    { VariableAccess =
X        VariableName
X        [ ComponentSelector ]* .
X      VariableName =
X        "variable" | "varparam" .
X      ComponentSelector =
X        Expression "index" |
X        "field" . }
X
X      variable2{level, displ}:
X        begin
X          level := st[p + 1];
X          s := s + 1;
X          x := b;
X          while level > 0 do
X            begin
X              x := st[x];
X              level := level - 1
X            end;
X          st[s] := x + st[p + 2];
X          p := p + 3
X        end;
X
X      varparam2{level, displ}:
X        begin
X          level := st[p + 1];
X          s := s + 1;
X          x := b;
X          while level > 0 do
X            begin
X              x := st[x];
X              level := level - 1
X            end;
X          st[s] := st[x + st[p + 2]];
X          p := p + 3
X        end;
X
X      index2{lower, upper, length,
X          lineno}:
X        begin
X          lower := st[p + 1];
X          i := st[s];
X          s := s - 1;
X          if (i < lower) or
X            (i > st[p + 2]) then
X              rangeerror(st[p + 4])
X          else
X            begin
X              st[s] := st[s] +
X                (i - lower) *
X                  st[p + 3];
X               p := p + 5
X            end
X        end;
X
X      field2{displ}:
X        begin
X          st[s] :=
X            st[s] + st[p + 1];
X          p := p + 2
X        end;
X
X    { StandardFunctionDesignator =
X        FileFunctionDesignator |
X        MathFunctionDesignator .
X      FileFunctionDesignator =
X        "eol" | "eoln" . } 
X
X      eof2{lineno}:
X        begin
X          s := s + 1;
X          st[s] :=
X            ord(eof(inpfile));
X          p := p + 2
X        end;
X
X      eoln2{lineno}:
X        begin
X          s := s + 1;
X          st[s] :=
X            ord(eoln(inpfile));
X          p := p + 2
X        end;
X
X    { MathFunctionDesignator =
X        Expression [ "float" ]
X          MathFunctionIdentifier .
X      MathFunctionIdentifier =
X        Abs | "arctan" | "chr" |
X        "cos" | "exp" | "ln" |
X        "odd" | "pred" | "round" |
X        "sin" | Sqr | "sqrt" |
X        "succ" | "trunc" .
X      Abs =
X       "abs" | "absint" .
X      Sqr =
X       "sqr" | "sqrint" . }
X
X      float2:
X        begin
X          dx.a := st[s];
X          s := s + 1;
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X          p := p + 1
X        end;
X
X      abs2{lineno}:
X        begin
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := abs(dx.a);
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      absint2{lineno}:
X        begin
X          st[s] := abs(st[s]);
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      arctan2{lineno}:
X        begin
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := arctan(dx.a);
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      chr2{lineno}:
X        begin
X          x := st[s];
X          if (x < null) or (x > del)
X            then
X              rangeerror(st[p + 1])
X            else p := p + 2
X        end;
X
X      cos2{lineno}:
X        begin
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := cos(dx.a);
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      exp2{lineno}:
X        begin
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := exp(dx.a);
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X             rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      ln2{lineno}:
X        begin
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := ln(dx.a);
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      odd2:
X        begin
X          st[s] := ord(odd(st[s]));
X          p := p + 1
X        end;
X
X      pred2{minvalue, lineno}:
X        begin
X          if st[s] > st[p + 1] then
X            begin
X              st[s] := pred(st[s]);
X              p := p + 3
X            end
X          else
X            rangeerror(st[p + 2])
X        end;
X
X      round2{lineno}:
X        begin
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          s := s - 1;
X          st[s] := round(dx.a);
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      sin2{lineno}:
X        begin
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := sin(dx.a);
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      sqr2{lineno}:
X        begin
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := sqr(dx.a);
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      sqrint2{lineno}:
X        begin
X          st[s] := sqr(st[s]);
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      sqrt2{lineno}:
X        begin
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := sqrt(dx.a);
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      succ2{maxvalue, lineno}:
X        begin
X          if st[s] < st[p + 1] then
X            begin
X              st[s] := succ(st[s]);
X              p := p + 3
X            end
X          else
X            rangeerror(st[p + 2])
X        end;
X
X      trunc2{lineno}:
X        begin
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          s := s - 1;
X          st[s] := trunc(dx.a);
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X    { FunctionDesignator =
X       "result"
X         ActualParameterPart
X           "proccall" |
X      StandardFunctionDesignator .
X      ActualParameterPart =
X        [ ActualParameter ]* .
X      ActualParameter =
X        Expression [ "float" ] |
X        VariableAccess . }
X
X      result2{length}:
X        begin
X          s := s + st[p + 1];
X          p := p + 2
X        end;
X
X      proccall2{level, displ}:
X        begin
X          level := st[p + 1];
X          s := s + 1;
X          x := b;
X          while level > 0 do
X            begin
X              x := st[x];
X              level := level - 1
X            end;
X          st[s] := x;
X          st[s + 2] := p + 3;
X          p := p + st[p + 2]
X        end;
X
X    { ConstantFactor =
X        "ordconst"| "realconst" |
X        "strconst" . }
X
X      ordconst2{value}:
X        begin
X          s := s + 1;
X          st[s] := st[p + 1];
X          p := p + 2
X        end;
X
X      realconst2{value}:
X        begin
X          st[s + 1] := st[p + 1];
X          st[s + 2] := st[p + 2];
X          s := s + 2;
X          p := p + 3
X        end;
X
X      stringconst2{length, value}:
X        begin
X          length := st[p + 1];
X          for i := 1 to length do
X            st[s + i] :=
X              st[p + i + 1];
X          for i := length + 1
X            to maxstring do
X              st[s + i] := null;
X          s := s + maxstring;
X          p := p + length + 2
X        end;
X
X    { Factor =
X        ConstantFactor |
X        VariableAccess "value" |
X        FunctionDesignator |
X        Expression |
X        Factor [ "not" ] . }
X
X      value2{length}:
X        begin
X          length := st[p + 1];
X          x := st[s];
X          for i := 0 to
X            length - 1 do
X              st[s + i] :=
X                st[x + i];
X          s := s + length - 1;
X          p := p + 2
X        end;
X
X      not2:
X        begin
X          if st[s] = ord(true)
X            then
X              st[s] := ord(false)
X            else
X              st[s] := ord(true);
X          p := p + 1
X        end;
X
X    { Term =
X        Factor [ Factor [ Float ]
X          MultiplyingOperator ]* .
X      Float =
X        "floatleft" | "float" .
X      MultiplyingOperator =
X        Multiply | Divide |
X        "modulo" | "and" .
X      Multiply =
X        "multiply" | "multreal" .
X      Divide =
X        "divide" | "divreal" . }
X
X      floatleft2:
X        begin
X          dx.a := st[s - 2];
X          s := s + 1;
X          st[s] := st[s - 1];
X          st[s - 1] := st[s - 2];
X          st[s - 3] := dx.b;
X          st[s - 2] := dx.c;
X          p := p + 1
X        end;
X
X      multiply2{lineno}:
X        begin
X          s := s - 1;
X          st[s] :=
X            st[s] * st[s + 1];
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      divide2{lineno}:
X        begin
X          s := s - 1;
X          st[s] :=
X            st[s] div st[s + 1];
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      modulo2{lineno}:
X        begin
X          s := s - 1;
X          st[s] :=
X            st[s] mod st[s + 1];
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      multreal2{lineno}:
X        begin
X          dy.b := st[s - 1];
X          dy.c := st[s];
X          s := s - 2;
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := dx.a * dy.a;
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      divreal2{lineno}:
X        begin
X          dy.b := st[s - 1];
X          dy.c := st[s];
X          s := s - 2;
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := dx.a / dy.a;
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      and2:
X        begin
X          s := s - 1;
X          if st[s] = ord(true)
X            then
X              st[s] := st[s + 1];
X          p := p + 1
X        end;
X
X    { SimpleExpression =
X        Term [ Sign ]
X          [ Term [ Float ]
X            AddingOperator ]* .
X      Sign =
X        Empty | Minus .
X      Minus =
X        "minus" | "minusreal" .
X      AddingOperator =
X        Add | Subtract | "or" .
X      Add =
X        "add" | "addreal" .
X      Subtract =
X        "subtract" |
X        "subreal" . }
X
X      minus2{(lineno}:
X        begin
X          st[s] := - st[s];
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      minusreal2{lineno}:
X        begin
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := - dx.a;
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      add2{lineno}:
X        begin
X          s := s - 1;
X          st[s] :=
X            st[s] + st[s + 1];
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      subtract2{lineno}:
X        begin
X          s := s - 1;
X          st[s] :=
X            st[s] - st[s + 1];
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      addreal2{lineno}:
X        begin
X          dy.b := st[s - 1];
X          dy.c := st[s];
X          s := s - 2;
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := dx.a + dy.a;
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      subreal2{lineno}:
X        begin
X          dy.b := st[s - 1];
X          dy.c := st[s];
X          s := s - 2;
X          dx.b := st[s - 1];
X          dx.c := st[s];
X          dx.a := dx.a - dy.a;
X          st[s - 1] := dx.b;
X          st[s] := dx.c;
X        { if overflow then
X            rangeerror(st[p + 1])
X          else } p := p + 2
X        end;
X
X      or2:
X        begin
X          s := s - 1;
X          if st[s] = ord(false) then
X            st[s] := st[s + 1];
X          p := p + 1
X        end;
X
X    { Expression = SimpleExpression
X        [ SimpleExpression [ Float ]
X          RelationalOperator ] .
X      RelationalOperator =
X        Less | Equal | Greater |
X        NotGreater | NotEqual |
X        NotLess.
X      Less =
X        "lsord" | "lsreal" |
X        "lsstring" .
X      Equal =
X        "eqord" | "eqreal" |
X        "eqstrig" | "equal" .
X      Greater =
X        "grord" | "grreal" |
X        "grstring" .
X      NotGreater =
X        "ngord" | "ngreal" |
X        "ngstring" .
X      NotEqual =
X        "neord" | "nereal" |
X        "nestring" | "notequal" .
X      NotLess =
X        "nlord" | "nlreal" |
X        "nlstring" . }
X
X      lsord2:
X        begin
X          s := s - 1;
X          st[s] :=
X            ord(st[s] < st[s + 1]);
X          p := p + 1
X        end;
X
X      eqord2:
X        begin
X          s := s - 1;
X          st[s] :=
X            ord(st[s] = st[s + 1]);
X          p := p + 1
X        end;
X
X      grord2:
X        begin
X          s := s - 1;
X          st[s] :=
X            ord(st[s] > st[s + 1]);
X          p := p + 1
X        end;
X
X      ngord2:
X        begin
X          s := s - 1;
X          st[s] :=
X            ord(st[s] <= st[s + 1]);
X          p := p + 1
X        end;
X
X      neord2:
X        begin
X          s := s - 1;
X          st[s] :=
X            ord(st[s] <> st[s + 1]);
X          p := p + 1
X        end;
X
X      nlord2:
X        begin
X          s := s - 1;
X          st[s] :=
X            ord(st[s] >= st[s + 1]);
X          p := p + 1
X        end;
X
X      lsreal2:
X        begin
X          dy.b := st[s - 1];
X          dy.c := st[s];
X          s := s - 3;
X          dx.b := st[s];
X          dx.c := st[s + 1];
X          st[s] := ord(dx.a < dy.a);
X          p := p + 1
X        end;
X
X      eqreal2:
X        begin
X          dy.b := st[s - 1];
X          dy.c := st[s];
X          s := s - 3;
X          dx.b := st[s];
X          dx.c := st[s + 1];
X          st[s] := ord(dx.a = dy.a);
X          p := p + 1
X        end;
X
X      grreal2:
X        begin
X          dy.b := st[s - 1];
X          dy.c := st[s];
X          s := s - 3;
X          dx.b := st[s];
X          dx.c := st[s + 1];
X          st[s] := ord(dx.a > dy.a);
X          p := p + 1
X        end;
X
X      ngreal2:
X        begin
X          dy.b := st[s - 1];
X          dy.c := st[s];
X          s := s - 3;
X          dx.b := st[s];
X          dx.c := st[s + 1];
X          st[s] := ord(dx.a <= dy.a);
X          p := p + 1
X        end;
X
X      nereal2:
X        begin
X          dy.b := st[s - 1];
X          dy.c := st[s];
X          s := s - 3;
X          dx.b := st[s];
X          dx.c := st[s + 1];
X          st[s] := ord(dx.a <> dy.a);
X          p := p + 1
X        end;
X
X      nlreal2:
X        begin
X          dy.b := st[s - 1];
X          dy.c := st[s];
X          s := s - 3;
X          dx.b := st[s];
X          dx.c := st[s + 1];
X          st[s] := ord(dx.a >= dy.a);
X          p := p + 1
X        end;
X
X      lsstring2:
X        begin
X          y := s - maxstring + 1;
X          s := y - maxstring;
X          i := 0;
X          while (i < maxstring - 1)
X            and 
X              (st[s + i] = st[y + i])
X                 do i := i + 1;
X          st[s] := ord(st[s + i] <
X            st[y + i]);
X          p := p + 1
X        end;
X
X      eqstring2:
X        begin
X          y := s - maxstring + 1;
X          s := y - maxstring;
X          i := 0;
X          while (i < maxstring - 1)
X            and
X              (st[s + i] = st[y + i])
X                do i := i + 1;
X          st[s] := ord(st[s + i] =
X            st[y + i]);
X          p := p + 1
X        end;
X
X      grstring2:
X        begin
X          y := s - maxstring + 1;
X          s := y - maxstring;
X          i := 0;
X          while (i < maxstring - 1)
X            and
X              (st[s + i] = st[y + i])
X                do i := i + 1;
X          st[s] := ord(st[s + i] >
X            st[y + i]);
X          p := p + 1
X       end;
X
X      ngstring2:
X        begin
X          y := s - maxstring + 1;
X          s := y - maxstring;
X          i := 0;
X          while (i < maxstring - 1)
X            and
X              (st[s + i] = st[y + i])
X                do i := i + 1;
X          st[s] := ord(st[s + i] <=
X            st[y + i]);
X          p := p + 1
X        end;
X
X      nestring2:
X        begin
X          y := s - maxstring + 1;
X          s := y - maxstring;
X          i := 0;
X          while (i < maxstring - 1)
X            and
X              (st[s + i] = st[y + i])
X                do i := i + 1;
X          st[s] := ord(st[s + i] <>
X            st[y + i]);
X          p := p + 1
X        end;
X
X      nlstring2:
X        begin
X          y := s - maxstring + 1;
X          s := y - maxstring;
X          i := 0;
X          while (i < maxstring - 1)
X            and
X              (st[s + i] = st[y + i])
X                do i := i + 1;
X          st[s] := ord(st[s + i] >=
X            st[y + i]);
X          p := p + 1
X        end;
X
X      equal2{length}:
X        begin
X          length := st[p + 1];
X          y := s - length + 1;
X          s := y - length;
X          i := 0;
X          while (i < length - 1) and
X            (st[s + i] = st[y + i])
X              do i := i + 1;
X          st[s] := ord(st[s + i] =
X            st[y + i]);
X          p := p + 2
X        end;
X
X      notequal2{length}:
X        begin
X          length := st[p + 1];
X          y := s - length + 1;
X          s := y - length;
X          i := 0;
X          while (i < length - 1) and
X           (st[s + i] = st[y + i])
X             do i := i + 1;
X          st[s] := ord(st[s + i] <>
X            st[y + i]);
X           p := p + 2
X      end;
X
X    { AssignmentStatement =
X        VariableAccess Expression
X          [ "float" ] "assign" . }
X
X      assign2{length}:
X        begin
X          length := st[p + 1];
X          s := s - length - 1;
X          x := st[s + 1];
X          y := s + 2;
X          for i := 0 to
X            length - 1 do
X              st[x + i] :=
X                st[y + i];
X          p := p + 2
X        end;
X
X    { ReadStatement =
X        ReadParameters |
X        [ ReadParameters ]
X          "readln" .
X      ReadParameters =
X        ReadParameter
X          [ ReadParameter ]* .
X        ReadParameter =
X          VariableAccess Read .
X        Read =
X          "read" | "readint" |
X          "readreal" . }
X
X      read2{lineno}:
X        begin
X          read(inpfile, cx);
X          st[st[s]] := ord(cx);
X          s := s - 1;
X          p := p + 2
X        end;
X
X      readint2{lineno}:
X        begin
X          read(inpfile,
X            st[st[s]]);
X          s := s - 1;
X          p := p + 2
X        end;
X
X      readreal2{lineno}:
X        begin
X          read(inpfile, dx.a);
X          y := st[s];
X          s := s - 1;
X          st[y] := dx.b;
X          st[y + 1] := dx.c;
X          p := p + 2
X       end;
X
X      readln2{lineno}:
X        begin
X          readln(inpfile);
X          p := p + 2
X        end;
X
X    { WriteStatement =
X        WriteParameters |
X        [ WriteParameters ]
X          "writeln" .
X      WriteParameters =
X        WriteParameter
X          [ WriteParameter ]* .
X      WriteParameter =
X        Expression
X          [ TotalWidth
X            [ FracDigits ] ]
X              "writereal" |
X        Expression
X          [ TotalWidth ]
X            OtherWrite .
X      OtherWrite =
X        "write" | "writebool" |
X        "writeint" |
X        "writestring" .
X      TotalWidth =
X        Expression .
X      FracDigits =
X        Expression . }
X
X      write2{option, lineno}:
X        begin
X          if st[p + 1] = ord(true)
X            then
X              begin
X                write(outfile,
X                  chr(st[s - 1]):
X                    st[s]);
X               s := s - 2
X              end
X            else
X              begin
X                write(outfile,
X                  chr(st[s]));
X                s := s - 1
X              end;
X          p := p + 3
X        end;
X
X      writebool2{option, lineno}:
X        begin
X          if st[p + 1] = ord(true)
X            then
X              begin
X                write(outfile,
X                  (st[s - 1] = 1)
X                    :st[s]);
X                s := s - 2
X              end
X            else
X              begin
X                write(outfile,
X                  st[s] = 1);
X                s := s - 1
X              end;
X          p := p + 3
X        end;
X
X      writeint2{option, lineno}:
X        begin
X          if st[p + 1] = ord(true)
X            then
X              begin
X                write(outfile,
X                  st[s - 1]:
X                    st[s]);
X                s := s - 2
X              end
X            else
X              begin
X                write(outfile,
X                  st[s]);
X                s := s - 1
X              end;
X          p := p + 3
X        end;
X
X      writereal2{option1, option2,
X          lineno}:
X        begin
X          if st[p + 1] = ord(true)
X            then
X              if st[p + 2] =
X                ord(true) then
X                  begin
X                    s := s - 4;
X                    dx.b :=
X                      st[s + 1];
X                    dx.c :=
X                      st[s + 2];
X                    m :=
X                      st[s + 3];
X                    n :=
X                      st[s + 4];
X                    write(outfile,
X                      dx.a:m:n)
X                  end
X                else
X                  begin
X                    s := s - 3;
X                    dx.b :=
X                      st[s + 1];
X                    dx.c :=
X                      st[s + 2];
X                    m :=
X                      st[s + 3];
X                    write(outfile,
X                      dx.a:m)
X                  end
X            else
X              begin
X                s := s - 2;
X                dx.b := st[s + 1];
X                dx.c := st[s + 2];
X                write(outfile,
X                  dx.a);
X              end;
X          p := p + 4
X        end;
X
X      writestring2{option, lineno}:
X        begin
X          if st[p + 1] = ord(true)
X            then
X              begin
X              { write(outfile,
X                  sx:width) }
X                width := st[s];
X                s := s - 1;
X                popstring(sx);
X                writestring(outfile,
X                  sx, width)
X              end
X            else
X              begin
X              { write(outfile, sx) }
X                popstring(sx);
X                writestring(outfile,
X                  sx,
X                  stringlength(sx))
X              end;
X          p := p + 3
X        end;
X
X      writeln2{lineno}:
X        begin
X          writeln(outfile);
X          p := p + 2
X        end;
X
X    { OpenStatement =
X        OpenParameters .
X      OpenParameters =
X        OpenParameter
X          [ OpenParameter ]* .
X      OpenParameter =
X        VariableAccess "open" . }
X
X      open2{lineno}:
X        begin
X          cmax := cmax + 1;
X          if cmax > maxchan then
X            error(st[p + 1],
X              maxchan5)
X          else
X            begin
X              open[cmax] := 0;
X              st[st[s]] := cmax;
X              s := s - 1;
X              p := p + 2
X            end
X        end;
X
X    { ReceiveStatement =
X        ReceiveParameters .
X      ReceiveParameters =
X        ChannelExpression
X          "checkio"
X            InputVariableList
X              "endio" .
X      ChannelExpression =
X        Expression .
X      InputVariableList =
X        InputVariableAccess
X          [ InputVariableAccess ]*
X            .
X      InputVariableAccess =
X        VariableAccess
X          "receive" . }
X
X      checkio2{lineno}:
X        begin
X          c := st[s];          
X          if (c < 1) or (c > cmax)
X            then
X              error(st[p + 1],
X                channel4)
X          else p := p + 2
X        end;
X
X      endio2:
X        begin
X          s := s - 1;
X          p := p + 1
X        end;
X
X      receive2{typeno, length,
X          lineno}:
X        begin
X          typeno := st[p + 1];
X          length := st[p + 2];
X          lineno := st[p + 3];
X          c := st[s - 1];
X          si := open[c];
X          if si = 0 then
X            begin
X              s := s + 3;
X              st[s - 2] := -typeno;
X              st[s - 1] := p + 4;
X              st[s] := b;
X              open[c] := s;
X              select(lineno)
X            end
X          else
X            begin
X              typeno2 := st[si - 2];
X              if typeno = typeno2 then
X                begin
X                  pi := st[si - 1];
X                  bi := st[si];
X                  si :=
X                    si - length - 3;
X                  x := st[s] - 1;
X                  s := s - 1;
X                  for i := 1 to length
X                    do
X                      st[x + i] :=
X                        st[si + i];
X                  open[c] := 0;
X                  activate(bi, si, pi);
X                  p := p + 4
X                end
X              else if typeno2 < 0 then
X                error(lineno,
X                  contention4)
X              else
X                error(lineno, type4)
X            end
X        end;
X
X    { SendStatement =
X        SendParameters .
X      SendParameters =
X        ChannelExpression
X          "checkio"
X            OutputExpressionList
X              "endio" .
X      OutputExpressionList =
X        OutputExpression
X          [ OutputExpression ]* .
X      OutputExpression =
X        Expression "send" . }
X
X      send2{typeno, length,
X          lineno}:
X        begin
X          typeno := st[p + 1];
X          length := st[p + 2];
X          lineno := st[p + 3];
X          c := st[s - length];
X          si := open[c];
X          if si = 0 then
X            begin
X              s := s + 3;
X              st[s - 2] := typeno;
X              st[s - 1] := p + 4;
X              st[s] := b;
X              open[c] := s;
X              select(lineno)
X            end
X          else
X            begin
X              typeno2 := st[si - 2];
X              if typeno = -typeno2 then
X                begin
X                  pi := st[si - 1];
X                  bi := st[si];
X                  si := si - 4;
X                  x := st[si + 1] - 1;
X                  s := s - length;
X                  for i := 1 to length
X                    do
X                      st[x + i] :=
X                        st[s + i];
X                  open[c] := 0;
X                  activate(bi, si, pi);
X                  p := p + 4
X                end
X              else if typeno2 > 0 then
X                error(lineno,
X                  contention4)
X              else
X                error(lineno, type4)
X            end
X        end;
X
X    { ProcedureStatement =
X        ActualParameterPart
X          "proccall" |
X        StandardProcedureStatement .
X      StandardProcedureStatement =
X        ReadStatement |
X        WriteStatement |
X        OpenStatement |
X        ReceiveStatement |
X        SendStatement .
X      IfStatement =
X        Expression "do" Statement
X          [ "goto" Statement ] .
X      WhileStatement =
X        Expression "do"
X          Statement "goto" .
X      RepeatStatement =
X        StatementSequence
X         Expression "do" . }
X
X      do2{displ}:
X        begin
X          if st[s] = ord(true) then
X            p := p + 2
X          else p := p + st[p + 1];
X          s := s - 1
X        end;
X
X      goto2{displ}:
X        p := p + st[p + 1];
X
X    { ForStatement =
X        ForClause ForOption .
X      ForClause =
X        VariableAccess
X          Expression "for" .
X      ForOption =
X        UpClause | DownClause .
X      UpClause =
X        Expression "to"
X          Statement "endto" .
X      DownClause =
X        Expression "downto"
X          Statement "enddown" . }
X
X      for2:
X        begin
X          st[st[s - 1]] := st[s];
X          s := s - 1;
X          p := p + 1
X        end;
X
X      to2{displ}:
X        begin
X          if st[st[s - 1]] <= st[s]
X            then p := p + 2
X            else
X              begin
X                s := s - 2;
X                p := p + st[p + 1]
X              end
X        end;
X
X      endto2{disp}:
X        begin
X          x := st[s - 1];
X          st[x] := st[x] + 1;
X          p := p + st[p + 1]
X        end;
X
X      downto2{displ}:
X        begin
X          if st[st[s - 1]] >= st[s]
X            then p := p + 2
X            else
X              begin
X                s := s - 2;
X                p := p + st[p + 1]
X              end
X        end;
X
X      enddown2{displ}:
X        begin
X          x := st[s - 1];
X          st[x] := st[x] - 1;
X          p := p + st[p + 1]
X        end;
X
X    { CaseStatement =
X        Expression "goto"
X          CaseList "case" .
X      CaseList =
X        StatementSequence . }
X
X      case2{
X        lineno, length, table}:
X          begin
X            x := st[s];
X            s := s - 1;
X            { binary search }  
X            i := 1;
X            j := st[p + 2];
X            while i < j do
X              begin
X                k :=
X                 (i + j) div 2;
X                m := p + 2*k + 1;
X                if st[m] < x
X                  then i := k + 1
X                  else j := k
X              end;
X            m := p + 2*i + 1;
X            if st[m] = x then
X              p := p + st[m + 1]
X            else
X              error(st[p + 1],
X                case4)
X          end;
X
X    { ParallelStatement =
X        "parallel"
X          ProcessStatementList
X            "endparallel" .
X      ProcessStatementList =
X        ProcessStatement
X          [ ProcessStatement ]* .
X      ProcessStatement =
X        "process"
X          StatementSequence
X            "endprocess" . }
X
X      parallel2:
X        begin
X           s := s + 1;
X           st[s] := 0;
X           p := p + 1
X        end;
X
X      endparallel2{lineno}:
X        select(st[p + 1]);
X
X      process2{blockno,
X        templength, displ,
X          lineno}:
X        begin
X          st[s] := st[s] + 1;
X          blockno := st[p + 1];
X          bi := free[blockno];
X          if bi = 0 then
X            begin
X              bi := t + 1;
X              t :=
X                bi + st[p + 2] + 4
X            end
X          else
X            free[blockno] :=
X              st[bi];
X          if t > maxaddr then
X            memorylimit(st[p + 4])
X          else
X            begin
X              st[bi] := b;
X              st[bi + 1] := s;
X              si := bi + 4;
X              st[si] := blockno;
X              activate(bi, si,
X                p + 5);
X              p := p + st[p + 3]
X            end
X        end;
X
X      endprocess2{displ, lineno}:
X        begin
X          blockno := st[s];
X          x := b;
X          b := st[x];
X          s := st[x + 1];
X          st[x] := free[blockno];
X          free[blockno] := x;
X          st[s] := st[s] - 1;
X          if st[s] > 0 then
X            select(st[p + 2])
X          else
X            begin
X              s := s - 1;
X              p := p + st[p + 1]
X            end
X        end;
X
X    { ForallStatement =
X        IndexVariableDeclaration       
X          "forall" Statement
X            "endall" .
X      IndexVariableDeclaration =
X        Expression Expression . }
X
X      forall2{blockno,
X        templength, displ,
X          lineno}:
X        begin
X          upper := st[s];
X          lower := st[s - 1];
X          if lower <= upper then
X            begin
X              s := s - 1;
X              st[s] :=
X                upper - lower + 1;
X              blockno :=
X                st[p + 1];
X              templength :=
X                st[p + 2];
X              lineno := st[p + 4];
X              for i := lower to
X                upper do
X              begin
X                bi :=
X                  free[blockno];
X                if bi = 0 then
X                  begin
X                    bi := t + 1;
X                    t := bi +
X                      templength + 5
X                  end
X                else
X                  free[blockno] :=
X                    st[bi];
X                if t > maxaddr then
X                  memorylimit(lineno)
X                else
X                  begin
X                    st[bi] := b;
X                    st[bi + 1] := s;
X                    st[bi + 4] := i;
X                    si := bi + 5;
X                    st[si] :=
X                      blockno;
X                    activate(bi, si,
X                      p + 5)
X                  end
X              end;
X              select(lineno)
X            end
X          else { lower > upper }
X            begin
X              s := s - 2;
X              p := p + st[p + 3]
X            end
X        end;
X
X      endall2{lineno}:
X        begin
X          blockno := st[s];
X          x := b;
X          b := st[x];
X          s := st[x + 1];
X          st[x] := free[blockno];
X          free[blockno] := x;
X          st[s] := st[s] - 1;
X          if st[s] > 0 then
X            select(st[p + 2])
X          else
X            begin
X              s := s - 1;
X              p := p + 2
X            end
X        end;
X
X    { AssumeStatement =
X        Expression "assume" . }
X
X      assume2{lineno}:
X        begin
X          x := st[s];
X          s := s - 1;
X          if x = ord(false) then
X            error(st[p + 1],
X              assume4)
X          else p := p + 2
X        end;
X
X    { Statement =
X        AssignmentStatement |
X        ProcedureStatement |
X        IfStatement |
X        WhileStatement |
X        RepeatStatement |
X        ForStatement |
X        CaseStatement |
X        CompoundStatement |
X        ParallelStatement |
X        ForallStatement |
X        AssumeStatement |
X        EmptyStatement .
X      EmptyStatement =  .
X      StatementSequence =
X        Statement [ Statement ]* .
X      CompoundStatement =
X        StatementSequence .
X      Block =
X        [ ProcedureDeclaration ]*
X          CompoundStatement .
X      ProcedureDeclaration =
X        "procedure" Block
X           "endproc" . }
X
X      procedure2{blockno,
X        paramlength, varlength,
X          templength, displ,
X            lineno}:
X        begin
X          st[s + 1] :=
X            s - st[p + 2] - 1;
X          st[s + 3] := b;
X          b := s;
X          blockno := st[p + 1];
X          s := free[blockno];
X          if s = 0 then
X            begin
X              s := t + 1;
X              t := s + st[p + 4];
X              if t > maxaddr then
X                memorylimit(
X                  st[p + 6])
X            end
X          else
X            free[blockno] := st[s];
X          st[s] := blockno;
X          p := p + st[p + 5]
X        end;
X
X      endproc2:
X        begin
X          blockno := st[s];
X          x := s;
X          s := st[b + 1];
X          p := st[b + 2];
X          b := st[b + 3];
X          st[x] := free[blockno];
X          free[blockno] := x
X        end;
X
X    { Program =
X        "program" Block
X          "endprog" . }
X
X      program2{blockno,
X        varlength, templength,
X          displ, lineno}:
X        begin
X          for i := 1 to maxblock
X            do free[i] := 0;
X          ready := 0;
X          cmax := 0;
X          b := stackbottom;
X          s := b + st[p + 2] + 4;
X          t := s + st[p + 3];
X          if t > maxaddr then
X            memorylimit(st[p + 5])
X          else p := p + st[p + 4]
X        end;
X
X      endprog2:
X        running := false;
X
X    { localvar(displ) =
X        variable(0, displ) . }
X
X      localvar2{displ}:
X        begin
X          s := s + 1;
X          st[s] := b + st[p + 1];
X          p := p + 2
X        end;
X
X    { localvalue(displ) =
X        localvar(displ)
X          value(1) . }
X
X      localvalue2{displ}:
X        begin
X          s := s + 1;
X          st[s] :=
X            st[b + st[p + 1]];
X          p := p + 2
X        end;
X
X    { localreal(displ) =
X        localvar(displ)
X          value(2) . }
X
X      localreal2{displ}:
X        begin
X          x := b + st[p + 1];
X          s := s + 2;
X          st[s - 1] := st[x];
X          st[s] := st[x + 1];
X          p := p + 2
X        end;
X
X    { globalvar(displ) =
X        variable(1, displ) . }
X
X      globalvar2{displ}:
X        begin
X          s := s + 1;
X          st[s] :=
X            st[b] + st[p + 1];
X          p := p + 2
X        end;
X
X    { globalvalue(displ) =
X        globalvar(displ)
X          value(1) . }
X
X      globalvalue2{displ}:
X        begin
X          s := s + 1;
X          st[s] := st[
X            st[b] + st[p + 1]];
X          p := p + 2
X        end;
X
X    { ordvalue =
X        value(1) . }
X
X      ordvalue2:
X        begin
X          st[s] := st[st[s]];
X          p := p + 1
X        end;
X
X    { realvalue =
X        value(2) . }
X
X      realvalue2:
X        begin
X          x := st[s];
X          s := s + 1;
X          st[s - 1] := st[x];
X          st[s] := st[x + 1];
X          p := p + 1
X        end;
X
X    { ordassign =
X        assign(1) . }
X
X      ordassign2:
X        begin
X          st[st[s - 1]] := st[s];
X          s := s - 2;
X          p := p + 1
X        end;
X
X    { realassign =
X        assign(2) . }
X
X      realassign2:
X        begin
X          s := s - 3;
X          x := st[s + 1];
X          st[x] := st[s + 2];
X          st[x + 1] := st[s + 3];
X          p := p + 1
X        end;
X
X    { globalcall(displ) =
X        proccall(1, displ) . }
X
X      globalcall2{displ}:
X        begin
X          s := s + 1;
X          st[s] := st[b];
X          st[s + 2] := p + 2;
X          p := p + st[p + 1]
X        end
X
X    end
end { run };
X
procedure readtime(
X var t:  integer);
begin
X  { A nonstandard function reads
X    the processor time in ms }
X  t := clock
end;
X
procedure writetime(
X  var outfile: text;
X  t1, t2: integer);
begin
X  { Outputs the time interval
X    t2 - t1 ms in seconds }
X  writeln(outfile);
X  writeln(outfile,
X    (t2 - t1 + 500) div 1000:1,
X    ' s')
end;
X
procedure runtime(
X  var codefile: binary;
X  var inpfile, outfile: text);
var t1, t2: integer;
begin
X  readtime(t1);
X  run(codefile, inpfile, outfile);
X  readtime(t2);
X  writetime(outfile, t1, t2)
end;
X
procedure openoutput(
X  var codefile: binary;
X  var inpfile: text;
X  outname: phrase);
var outfile: text;
begin
X  if outname = screen then
X    begin
X      writeln(output);
X      runtime(codefile,
X        inpfile, output);
X      writeln(output)
X    end
X  else
X    begin
X      { nonstandard rewrite }
X      rewrite(outfile, outname);
X      runtime(codefile,
X        inpfile, outfile)
X    end
end;
X
procedure openinput(
X  var codefile: binary;
X  inpname, outname: phrase);
var inpfile: text;
begin
X  if inpname = keyboard then
X    openoutput(codefile,
X      input, outname)
X  else
X    begin
X      { nonstandard reset }
X      reset(inpfile, inpname);
X      openoutput(codefile,
X        inpfile, outname)
X    end
end;
X
procedure start;
var codename, inpname,
X  outname: phrase;
X  codefile: binary;
X  select: boolean;
begin
X  write('    code = ');
X  readphrase(codename);
X  write('    select files? ');
X  readboolean(select);
X  if select then
X    begin
X      write('    input = ');
X      readphrase(inpname);
X      write('    output = ');
X      readphrase(outname);
X      { nonstandard reset }
X      reset(codefile, codename);
X      openinput(codefile,
X        inpname, outname)
X    end
X  else
X    begin
X      { nonstandard reset }
X      reset(codefile, codename);
X      writeln(output);
X      runtime(codefile, input,
X        output);
X      writeln(output)
X    end
end;
X
begin start end.
SHAR_EOF
  $shar_touch -am 1029021698 'interpret.p' &&
  chmod 0600 'interpret.p' ||
  $echo 'restore of' 'interpret.p' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'interpret.p:' 'MD5 check failed'
060947f1fe175f0b623f56c41570e9ca  interpret.p
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'interpret.p'`"
    test 41292 -eq "$shar_count" ||
    $echo 'interpret.p:' 'original size' '41292,' 'current size' "$shar_count!"
  fi
fi
# ============= sun3.user ==============
if test -f 'sun3.user' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'sun3.user' '(file already exists)'
else
  $echo 'x -' extracting 'sun3.user' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sun3.user' &&
echo Compiling Sun3 SuperPascal:
pc -s -H -O -f68881 -o sc compile.p
pc -s -H -O -f68881 -o sr interpret.p
SHAR_EOF
  $shar_touch -am 1029021698 'sun3.user' &&
  chmod 0600 'sun3.user' ||
  $echo 'restore of' 'sun3.user' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'sun3.user:' 'MD5 check failed'
849598467a16ed99029b24ee996e7ce1  sun3.user
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'sun3.user'`"
    test 107 -eq "$shar_count" ||
    $echo 'sun3.user:' 'original size' '107,' 'current size' "$shar_count!"
  fi
fi
# ============= sun4.user ==============
if test -f 'sun4.user' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'sun4.user' '(file already exists)'
else
  $echo 'x -' extracting 'sun4.user' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'sun4.user' &&
echo Compiling Sun4 SuperPascal:
pc -s -H -O -cg89 -o sc compile.p
pc -s -H -O -cg89 -o sr interpret.p
SHAR_EOF
  $shar_touch -am 1029021698 'sun4.user' &&
  chmod 0600 'sun4.user' ||
  $echo 'restore of' 'sun4.user' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'sun4.user:' 'MD5 check failed'
569244459ad2bad4557c382f686137fe  sun4.user
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'sun4.user'`"
    test 103 -eq "$shar_count" ||
    $echo 'sun4.user:' 'original size' '103,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh04862
exit 0

